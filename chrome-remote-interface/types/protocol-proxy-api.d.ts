// deno-lint-ignore-file adjacent-overload-signatures
/* eslint-disable @typescript-eslint/adjacent-overload-signatures */
/* eslint-disable no-unused-vars */
/**********************************************************************
 * Auto-generated by protocol-dts-generator.ts, do not edit manually. *
 **********************************************************************/

import Protocol from "./protocol.d.ts";

/**
 * API generated from Protocol commands and events.
 */
export namespace ProtocolProxyApi {
    export type SessionId = string;

    export type ProtocolApi = {
        Accessibility: AccessibilityApi;

        Animation: AnimationApi;

        Audits: AuditsApi;

        BackgroundService: BackgroundServiceApi;

        Browser: BrowserApi;

        CSS: CSSApi;

        CacheStorage: CacheStorageApi;

        Cast: CastApi;

        DOM: DOMApi;

        DOMDebugger: DOMDebuggerApi;

        EventBreakpoints: EventBreakpointsApi;

        DOMSnapshot: DOMSnapshotApi;

        DOMStorage: DOMStorageApi;

        Database: DatabaseApi;

        DeviceOrientation: DeviceOrientationApi;

        Emulation: EmulationApi;

        HeadlessExperimental: HeadlessExperimentalApi;

        IO: IOApi;

        IndexedDB: IndexedDBApi;

        Input: InputApi;

        Inspector: InspectorApi;

        LayerTree: LayerTreeApi;

        Log: LogApi;

        Memory: MemoryApi;

        Network: NetworkApi;

        Overlay: OverlayApi;

        Page: PageApi;

        Performance: PerformanceApi;

        PerformanceTimeline: PerformanceTimelineApi;

        Security: SecurityApi;

        ServiceWorker: ServiceWorkerApi;

        Storage: StorageApi;

        SystemInfo: SystemInfoApi;

        Target: TargetApi;

        Tethering: TetheringApi;

        Tracing: TracingApi;

        Fetch: FetchApi;

        WebAudio: WebAudioApi;

        WebAuthn: WebAuthnApi;

        Media: MediaApi;

    }


    export type AccessibilityApi = {
        /**
         * Disables the accessibility domain.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
         * This turns on accessibility for the page, which can impact performance until accessibility is disabled.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
         */
        getPartialAXTree(params?: Protocol.Accessibility.GetPartialAXTreeRequest, sessionId?: SessionId): Promise<Protocol.Accessibility.GetPartialAXTreeResponse>;

        /**
         * Fetches the entire accessibility tree for the root Document
         */
        getFullAXTree(params?: Protocol.Accessibility.GetFullAXTreeRequest, sessionId?: SessionId): Promise<Protocol.Accessibility.GetFullAXTreeResponse>;

        /**
         * Fetches the root node.
         * Requires `enable()` to have been called previously.
         */
        getRootAXNode(params?: Protocol.Accessibility.GetRootAXNodeRequest, sessionId?: SessionId): Promise<Protocol.Accessibility.GetRootAXNodeResponse>;

        /**
         * Fetches a node and all ancestors up to and including the root.
         * Requires `enable()` to have been called previously.
         */
        getAXNodeAndAncestors(params?: Protocol.Accessibility.GetAXNodeAndAncestorsRequest, sessionId?: SessionId): Promise<Protocol.Accessibility.GetAXNodeAndAncestorsResponse>;

        /**
         * Fetches a particular accessibility node by AXNodeId.
         * Requires `enable()` to have been called previously.
         */
        getChildAXNodes(params: Protocol.Accessibility.GetChildAXNodesRequest, sessionId?: SessionId): Promise<Protocol.Accessibility.GetChildAXNodesResponse>;

        /**
         * Query a DOM node's accessibility subtree for accessible name and role.
         * This command computes the name and role for all nodes in the subtree, including those that are
         * ignored for accessibility, and returns those that mactch the specified name and role. If no DOM
         * node is specified, or the DOM node does not exist, the command returns an error. If neither
         * `accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.
         */
        queryAXTree(params?: Protocol.Accessibility.QueryAXTreeRequest, sessionId?: SessionId): Promise<Protocol.Accessibility.QueryAXTreeResponse>;

        /**
         * The loadComplete event mirrors the load complete event sent by the browser to assistive
         * technology when the web page has finished loading.
         */
        on(event: "loadComplete", listener: (params: Protocol.Accessibility.LoadCompleteEvent) => void): void;
        on(event: `loadComplete.${SessionId}`, listener: (params: Protocol.Accessibility.LoadCompleteEvent) => void): void;
        once(event: "loadComplete", listener: (params: Protocol.Accessibility.LoadCompleteEvent) => void): void;
        once(event: `loadComplete.${SessionId}`, listener: (params: Protocol.Accessibility.LoadCompleteEvent) => void): void;
        off(event: "loadComplete", listener: (params: Protocol.Accessibility.LoadCompleteEvent) => void): void;
        off(event: `loadComplete.${SessionId}`, listener: (params: Protocol.Accessibility.LoadCompleteEvent) => void): void;
        loadComplete(sessionId?: SessionId): Promise<Protocol.Accessibility.LoadCompleteEvent>;

        /**
         * The nodesUpdated event is sent every time a previously requested node has changed the in tree.
         */
        on(event: "nodesUpdated", listener: (params: Protocol.Accessibility.NodesUpdatedEvent) => void): void;
        on(event: `nodesUpdated.${SessionId}`, listener: (params: Protocol.Accessibility.NodesUpdatedEvent) => void): void;
        once(event: "nodesUpdated", listener: (params: Protocol.Accessibility.NodesUpdatedEvent) => void): void;
        once(event: `nodesUpdated.${SessionId}`, listener: (params: Protocol.Accessibility.NodesUpdatedEvent) => void): void;
        off(event: "nodesUpdated", listener: (params: Protocol.Accessibility.NodesUpdatedEvent) => void): void;
        off(event: `nodesUpdated.${SessionId}`, listener: (params: Protocol.Accessibility.NodesUpdatedEvent) => void): void;
        nodesUpdated(sessionId?: SessionId): Promise<Protocol.Accessibility.NodesUpdatedEvent>;

    }

    export type AnimationApi = {
        /**
         * Disables animation domain notifications.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables animation domain notifications.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Returns the current time of the an animation.
         */
        getCurrentTime(params: Protocol.Animation.GetCurrentTimeRequest, sessionId?: SessionId): Promise<Protocol.Animation.GetCurrentTimeResponse>;

        /**
         * Gets the playback rate of the document timeline.
         */
        getPlaybackRate(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Animation.GetPlaybackRateResponse>;

        /**
         * Releases a set of animations to no longer be manipulated.
         */
        releaseAnimations(params: Protocol.Animation.ReleaseAnimationsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Gets the remote object of the Animation.
         */
        resolveAnimation(params: Protocol.Animation.ResolveAnimationRequest, sessionId?: SessionId): Promise<Protocol.Animation.ResolveAnimationResponse>;

        /**
         * Seek a set of animations to a particular time within each animation.
         */
        seekAnimations(params: Protocol.Animation.SeekAnimationsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets the paused state of a set of animations.
         */
        setPaused(params: Protocol.Animation.SetPausedRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets the playback rate of the document timeline.
         */
        setPlaybackRate(params: Protocol.Animation.SetPlaybackRateRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets the timing of an animation node.
         */
        setTiming(params: Protocol.Animation.SetTimingRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Event for when an animation has been cancelled.
         */
        on(event: "animationCanceled", listener: (params: Protocol.Animation.AnimationCanceledEvent) => void): void;
        on(event: `animationCanceled.${SessionId}`, listener: (params: Protocol.Animation.AnimationCanceledEvent) => void): void;
        once(event: "animationCanceled", listener: (params: Protocol.Animation.AnimationCanceledEvent) => void): void;
        once(event: `animationCanceled.${SessionId}`, listener: (params: Protocol.Animation.AnimationCanceledEvent) => void): void;
        off(event: "animationCanceled", listener: (params: Protocol.Animation.AnimationCanceledEvent) => void): void;
        off(event: `animationCanceled.${SessionId}`, listener: (params: Protocol.Animation.AnimationCanceledEvent) => void): void;
        animationCanceled(sessionId?: SessionId): Promise<Protocol.Animation.AnimationCanceledEvent>;

        /**
         * Event for each animation that has been created.
         */
        on(event: "animationCreated", listener: (params: Protocol.Animation.AnimationCreatedEvent) => void): void;
        on(event: `animationCreated.${SessionId}`, listener: (params: Protocol.Animation.AnimationCreatedEvent) => void): void;
        once(event: "animationCreated", listener: (params: Protocol.Animation.AnimationCreatedEvent) => void): void;
        once(event: `animationCreated.${SessionId}`, listener: (params: Protocol.Animation.AnimationCreatedEvent) => void): void;
        off(event: "animationCreated", listener: (params: Protocol.Animation.AnimationCreatedEvent) => void): void;
        off(event: `animationCreated.${SessionId}`, listener: (params: Protocol.Animation.AnimationCreatedEvent) => void): void;
        animationCreated(sessionId?: SessionId): Promise<Protocol.Animation.AnimationCreatedEvent>;

        /**
         * Event for animation that has been started.
         */
        on(event: "animationStarted", listener: (params: Protocol.Animation.AnimationStartedEvent) => void): void;
        on(event: `animationStarted.${SessionId}`, listener: (params: Protocol.Animation.AnimationStartedEvent) => void): void;
        once(event: "animationStarted", listener: (params: Protocol.Animation.AnimationStartedEvent) => void): void;
        once(event: `animationStarted.${SessionId}`, listener: (params: Protocol.Animation.AnimationStartedEvent) => void): void;
        off(event: "animationStarted", listener: (params: Protocol.Animation.AnimationStartedEvent) => void): void;
        off(event: `animationStarted.${SessionId}`, listener: (params: Protocol.Animation.AnimationStartedEvent) => void): void;
        animationStarted(sessionId?: SessionId): Promise<Protocol.Animation.AnimationStartedEvent>;

    }

    export type AuditsApi = {
        /**
         * Returns the response body and size if it were re-encoded with the specified settings. Only
         * applies to images.
         */
        getEncodedResponse(params: Protocol.Audits.GetEncodedResponseRequest, sessionId?: SessionId): Promise<Protocol.Audits.GetEncodedResponseResponse>;

        /**
         * Disables issues domain, prevents further issues from being reported to the client.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables issues domain, sends the issues collected so far to the client by means of the
         * `issueAdded` event.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Runs the contrast check for the target page. Found issues are reported
         * using Audits.issueAdded event.
         */
        checkContrast(params?: Protocol.Audits.CheckContrastRequest, sessionId?: SessionId): Promise<void>;

        on(event: "issueAdded", listener: (params: Protocol.Audits.IssueAddedEvent) => void): void;
        on(event: `issueAdded.${SessionId}`, listener: (params: Protocol.Audits.IssueAddedEvent) => void): void;
        once(event: "issueAdded", listener: (params: Protocol.Audits.IssueAddedEvent) => void): void;
        once(event: `issueAdded.${SessionId}`, listener: (params: Protocol.Audits.IssueAddedEvent) => void): void;
        off(event: "issueAdded", listener: (params: Protocol.Audits.IssueAddedEvent) => void): void;
        off(event: `issueAdded.${SessionId}`, listener: (params: Protocol.Audits.IssueAddedEvent) => void): void;
        issueAdded(sessionId?: SessionId): Promise<Protocol.Audits.IssueAddedEvent>;

    }

    export type BackgroundServiceApi = {
        /**
         * Enables event updates for the service.
         */
        startObserving(params: Protocol.BackgroundService.StartObservingRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Disables event updates for the service.
         */
        stopObserving(params: Protocol.BackgroundService.StopObservingRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Set the recording state for the service.
         */
        setRecording(params: Protocol.BackgroundService.SetRecordingRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Clears all stored data for the service.
         */
        clearEvents(params: Protocol.BackgroundService.ClearEventsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Called when the recording state for the service has been updated.
         */
        on(event: "recordingStateChanged", listener: (params: Protocol.BackgroundService.RecordingStateChangedEvent) => void): void;
        on(event: `recordingStateChanged.${SessionId}`, listener: (params: Protocol.BackgroundService.RecordingStateChangedEvent) => void): void;
        once(event: "recordingStateChanged", listener: (params: Protocol.BackgroundService.RecordingStateChangedEvent) => void): void;
        once(event: `recordingStateChanged.${SessionId}`, listener: (params: Protocol.BackgroundService.RecordingStateChangedEvent) => void): void;
        off(event: "recordingStateChanged", listener: (params: Protocol.BackgroundService.RecordingStateChangedEvent) => void): void;
        off(event: `recordingStateChanged.${SessionId}`, listener: (params: Protocol.BackgroundService.RecordingStateChangedEvent) => void): void;
        recordingStateChanged(sessionId?: SessionId): Promise<Protocol.BackgroundService.RecordingStateChangedEvent>;

        /**
         * Called with all existing backgroundServiceEvents when enabled, and all new
         * events afterwards if enabled and recording.
         */
        on(event: "backgroundServiceEventReceived", listener: (params: Protocol.BackgroundService.BackgroundServiceEventReceivedEvent) => void): void;
        on(event: `backgroundServiceEventReceived.${SessionId}`, listener: (params: Protocol.BackgroundService.BackgroundServiceEventReceivedEvent) => void): void;
        once(event: "backgroundServiceEventReceived", listener: (params: Protocol.BackgroundService.BackgroundServiceEventReceivedEvent) => void): void;
        once(event: `backgroundServiceEventReceived.${SessionId}`, listener: (params: Protocol.BackgroundService.BackgroundServiceEventReceivedEvent) => void): void;
        off(event: "backgroundServiceEventReceived", listener: (params: Protocol.BackgroundService.BackgroundServiceEventReceivedEvent) => void): void;
        off(event: `backgroundServiceEventReceived.${SessionId}`, listener: (params: Protocol.BackgroundService.BackgroundServiceEventReceivedEvent) => void): void;
        backgroundServiceEventReceived(sessionId?: SessionId): Promise<Protocol.BackgroundService.BackgroundServiceEventReceivedEvent>;

    }

    export type BrowserApi = {
        /**
         * Set permission settings for given origin.
         */
        setPermission(params: Protocol.Browser.SetPermissionRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Grant specific permissions to the given origin and reject all others.
         */
        grantPermissions(params: Protocol.Browser.GrantPermissionsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Reset all permission management for all origins.
         */
        resetPermissions(params?: Protocol.Browser.ResetPermissionsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Set the behavior when downloading a file.
         */
        setDownloadBehavior(params: Protocol.Browser.SetDownloadBehaviorRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Cancel a download if in progress
         */
        cancelDownload(params: Protocol.Browser.CancelDownloadRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Close browser gracefully.
         */
        close(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Crashes browser on the main thread.
         */
        crash(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Crashes GPU process.
         */
        crashGpuProcess(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Returns version information.
         */
        getVersion(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Browser.GetVersionResponse>;

        /**
         * Returns the command line switches for the browser process if, and only if
         * --enable-automation is on the commandline.
         */
        getBrowserCommandLine(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Browser.GetBrowserCommandLineResponse>;

        /**
         * Get Chrome histograms.
         */
        getHistograms(params?: Protocol.Browser.GetHistogramsRequest, sessionId?: SessionId): Promise<Protocol.Browser.GetHistogramsResponse>;

        /**
         * Get a Chrome histogram by name.
         */
        getHistogram(params: Protocol.Browser.GetHistogramRequest, sessionId?: SessionId): Promise<Protocol.Browser.GetHistogramResponse>;

        /**
         * Get position and size of the browser window.
         */
        getWindowBounds(params: Protocol.Browser.GetWindowBoundsRequest, sessionId?: SessionId): Promise<Protocol.Browser.GetWindowBoundsResponse>;

        /**
         * Get the browser window that contains the devtools target.
         */
        getWindowForTarget(params?: Protocol.Browser.GetWindowForTargetRequest, sessionId?: SessionId): Promise<Protocol.Browser.GetWindowForTargetResponse>;

        /**
         * Set position and/or size of the browser window.
         */
        setWindowBounds(params: Protocol.Browser.SetWindowBoundsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Set dock tile details, platform-specific.
         */
        setDockTile(params?: Protocol.Browser.SetDockTileRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Invoke custom browser commands used by telemetry.
         */
        executeBrowserCommand(params: Protocol.Browser.ExecuteBrowserCommandRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Fired when page is about to start a download.
         */
        on(event: "downloadWillBegin", listener: (params: Protocol.Browser.DownloadWillBeginEvent) => void): void;
        on(event: `downloadWillBegin.${SessionId}`, listener: (params: Protocol.Browser.DownloadWillBeginEvent) => void): void;
        once(event: "downloadWillBegin", listener: (params: Protocol.Browser.DownloadWillBeginEvent) => void): void;
        once(event: `downloadWillBegin.${SessionId}`, listener: (params: Protocol.Browser.DownloadWillBeginEvent) => void): void;
        off(event: "downloadWillBegin", listener: (params: Protocol.Browser.DownloadWillBeginEvent) => void): void;
        off(event: `downloadWillBegin.${SessionId}`, listener: (params: Protocol.Browser.DownloadWillBeginEvent) => void): void;
        downloadWillBegin(sessionId?: SessionId): Promise<Protocol.Browser.DownloadWillBeginEvent>;

        /**
         * Fired when download makes progress. Last call has |done| == true.
         */
        on(event: "downloadProgress", listener: (params: Protocol.Browser.DownloadProgressEvent) => void): void;
        on(event: `downloadProgress.${SessionId}`, listener: (params: Protocol.Browser.DownloadProgressEvent) => void): void;
        once(event: "downloadProgress", listener: (params: Protocol.Browser.DownloadProgressEvent) => void): void;
        once(event: `downloadProgress.${SessionId}`, listener: (params: Protocol.Browser.DownloadProgressEvent) => void): void;
        off(event: "downloadProgress", listener: (params: Protocol.Browser.DownloadProgressEvent) => void): void;
        off(event: `downloadProgress.${SessionId}`, listener: (params: Protocol.Browser.DownloadProgressEvent) => void): void;
        downloadProgress(sessionId?: SessionId): Promise<Protocol.Browser.DownloadProgressEvent>;

    }

    export type CSSApi = {
        /**
         * Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
         * position specified by `location`.
         */
        addRule(params: Protocol.CSS.AddRuleRequest, sessionId?: SessionId): Promise<Protocol.CSS.AddRuleResponse>;

        /**
         * Returns all class names from specified stylesheet.
         */
        collectClassNames(params: Protocol.CSS.CollectClassNamesRequest, sessionId?: SessionId): Promise<Protocol.CSS.CollectClassNamesResponse>;

        /**
         * Creates a new special "via-inspector" stylesheet in the frame with given `frameId`.
         */
        createStyleSheet(params: Protocol.CSS.CreateStyleSheetRequest, sessionId?: SessionId): Promise<Protocol.CSS.CreateStyleSheetResponse>;

        /**
         * Disables the CSS agent for the given page.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
         * enabled until the result of this command is received.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Ensures that the given node will have specified pseudo-classes whenever its style is computed by
         * the browser.
         */
        forcePseudoState(params: Protocol.CSS.ForcePseudoStateRequest, sessionId?: SessionId): Promise<void>;

        getBackgroundColors(params: Protocol.CSS.GetBackgroundColorsRequest, sessionId?: SessionId): Promise<Protocol.CSS.GetBackgroundColorsResponse>;

        /**
         * Returns the computed style for a DOM node identified by `nodeId`.
         */
        getComputedStyleForNode(params: Protocol.CSS.GetComputedStyleForNodeRequest, sessionId?: SessionId): Promise<Protocol.CSS.GetComputedStyleForNodeResponse>;

        /**
         * Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
         * attributes) for a DOM node identified by `nodeId`.
         */
        getInlineStylesForNode(params: Protocol.CSS.GetInlineStylesForNodeRequest, sessionId?: SessionId): Promise<Protocol.CSS.GetInlineStylesForNodeResponse>;

        /**
         * Returns requested styles for a DOM node identified by `nodeId`.
         */
        getMatchedStylesForNode(params: Protocol.CSS.GetMatchedStylesForNodeRequest, sessionId?: SessionId): Promise<Protocol.CSS.GetMatchedStylesForNodeResponse>;

        /**
         * Returns all media queries parsed by the rendering engine.
         */
        getMediaQueries(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.CSS.GetMediaQueriesResponse>;

        /**
         * Requests information about platform fonts which we used to render child TextNodes in the given
         * node.
         */
        getPlatformFontsForNode(params: Protocol.CSS.GetPlatformFontsForNodeRequest, sessionId?: SessionId): Promise<Protocol.CSS.GetPlatformFontsForNodeResponse>;

        /**
         * Returns the current textual content for a stylesheet.
         */
        getStyleSheetText(params: Protocol.CSS.GetStyleSheetTextRequest, sessionId?: SessionId): Promise<Protocol.CSS.GetStyleSheetTextResponse>;

        /**
         * Returns all layers parsed by the rendering engine for the tree scope of a node.
         * Given a DOM element identified by nodeId, getLayersForNode returns the root
         * layer for the nearest ancestor document or shadow root. The layer root contains
         * the full layer tree for the tree scope and their ordering.
         */
        getLayersForNode(params: Protocol.CSS.GetLayersForNodeRequest, sessionId?: SessionId): Promise<Protocol.CSS.GetLayersForNodeResponse>;

        /**
         * Starts tracking the given computed styles for updates. The specified array of properties
         * replaces the one previously specified. Pass empty array to disable tracking.
         * Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
         * The changes to computed style properties are only tracked for nodes pushed to the front-end
         * by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
         * to the front-end, no updates will be issued for the node.
         */
        trackComputedStyleUpdates(params: Protocol.CSS.TrackComputedStyleUpdatesRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Polls the next batch of computed style updates.
         */
        takeComputedStyleUpdates(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.CSS.TakeComputedStyleUpdatesResponse>;

        /**
         * Find a rule with the given active property for the given node and set the new value for this
         * property
         */
        setEffectivePropertyValueForNode(params: Protocol.CSS.SetEffectivePropertyValueForNodeRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Modifies the keyframe rule key text.
         */
        setKeyframeKey(params: Protocol.CSS.SetKeyframeKeyRequest, sessionId?: SessionId): Promise<Protocol.CSS.SetKeyframeKeyResponse>;

        /**
         * Modifies the rule selector.
         */
        setMediaText(params: Protocol.CSS.SetMediaTextRequest, sessionId?: SessionId): Promise<Protocol.CSS.SetMediaTextResponse>;

        /**
         * Modifies the expression of a container query.
         */
        setContainerQueryText(params: Protocol.CSS.SetContainerQueryTextRequest, sessionId?: SessionId): Promise<Protocol.CSS.SetContainerQueryTextResponse>;

        /**
         * Modifies the expression of a supports at-rule.
         */
        setSupportsText(params: Protocol.CSS.SetSupportsTextRequest, sessionId?: SessionId): Promise<Protocol.CSS.SetSupportsTextResponse>;

        /**
         * Modifies the expression of a scope at-rule.
         */
        setScopeText(params: Protocol.CSS.SetScopeTextRequest, sessionId?: SessionId): Promise<Protocol.CSS.SetScopeTextResponse>;

        /**
         * Modifies the rule selector.
         */
        setRuleSelector(params: Protocol.CSS.SetRuleSelectorRequest, sessionId?: SessionId): Promise<Protocol.CSS.SetRuleSelectorResponse>;

        /**
         * Sets the new stylesheet text.
         */
        setStyleSheetText(params: Protocol.CSS.SetStyleSheetTextRequest, sessionId?: SessionId): Promise<Protocol.CSS.SetStyleSheetTextResponse>;

        /**
         * Applies specified style edits one after another in the given order.
         */
        setStyleTexts(params: Protocol.CSS.SetStyleTextsRequest, sessionId?: SessionId): Promise<Protocol.CSS.SetStyleTextsResponse>;

        /**
         * Enables the selector recording.
         */
        startRuleUsageTracking(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Stop tracking rule usage and return the list of rules that were used since last call to
         * `takeCoverageDelta` (or since start of coverage instrumentation)
         */
        stopRuleUsageTracking(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.CSS.StopRuleUsageTrackingResponse>;

        /**
         * Obtain list of rules that became used since last call to this method (or since start of coverage
         * instrumentation)
         */
        takeCoverageDelta(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.CSS.TakeCoverageDeltaResponse>;

        /**
         * Enables/disables rendering of local CSS fonts (enabled by default).
         */
        setLocalFontsEnabled(params: Protocol.CSS.SetLocalFontsEnabledRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
         * web font
         */
        on(event: "fontsUpdated", listener: (params: Protocol.CSS.FontsUpdatedEvent) => void): void;
        on(event: `fontsUpdated.${SessionId}`, listener: (params: Protocol.CSS.FontsUpdatedEvent) => void): void;
        once(event: "fontsUpdated", listener: (params: Protocol.CSS.FontsUpdatedEvent) => void): void;
        once(event: `fontsUpdated.${SessionId}`, listener: (params: Protocol.CSS.FontsUpdatedEvent) => void): void;
        off(event: "fontsUpdated", listener: (params: Protocol.CSS.FontsUpdatedEvent) => void): void;
        off(event: `fontsUpdated.${SessionId}`, listener: (params: Protocol.CSS.FontsUpdatedEvent) => void): void;
        fontsUpdated(sessionId?: SessionId): Promise<Protocol.CSS.FontsUpdatedEvent>;

        /**
         * Fires whenever a MediaQuery result changes (for example, after a browser window has been
         * resized.) The current implementation considers only viewport-dependent media features.
         */
        on(event: "mediaQueryResultChanged", listener: () => void): void;
        on(event: `mediaQueryResultChanged.${SessionId}`, listener: () => void): void;
        once(event: "mediaQueryResultChanged", listener: () => void): void;
        once(event: `mediaQueryResultChanged.${SessionId}`, listener: () => void): void;
        off(event: "mediaQueryResultChanged", listener: () => void): void;
        off(event: `mediaQueryResultChanged.${SessionId}`, listener: () => void): void;
        mediaQueryResultChanged(sessionId?: SessionId): Promise<void>;

        /**
         * Fired whenever an active document stylesheet is added.
         */
        on(event: "styleSheetAdded", listener: (params: Protocol.CSS.StyleSheetAddedEvent) => void): void;
        on(event: `styleSheetAdded.${SessionId}`, listener: (params: Protocol.CSS.StyleSheetAddedEvent) => void): void;
        once(event: "styleSheetAdded", listener: (params: Protocol.CSS.StyleSheetAddedEvent) => void): void;
        once(event: `styleSheetAdded.${SessionId}`, listener: (params: Protocol.CSS.StyleSheetAddedEvent) => void): void;
        off(event: "styleSheetAdded", listener: (params: Protocol.CSS.StyleSheetAddedEvent) => void): void;
        off(event: `styleSheetAdded.${SessionId}`, listener: (params: Protocol.CSS.StyleSheetAddedEvent) => void): void;
        styleSheetAdded(sessionId?: SessionId): Promise<Protocol.CSS.StyleSheetAddedEvent>;

        /**
         * Fired whenever a stylesheet is changed as a result of the client operation.
         */
        on(event: "styleSheetChanged", listener: (params: Protocol.CSS.StyleSheetChangedEvent) => void): void;
        on(event: `styleSheetChanged.${SessionId}`, listener: (params: Protocol.CSS.StyleSheetChangedEvent) => void): void;
        once(event: "styleSheetChanged", listener: (params: Protocol.CSS.StyleSheetChangedEvent) => void): void;
        once(event: `styleSheetChanged.${SessionId}`, listener: (params: Protocol.CSS.StyleSheetChangedEvent) => void): void;
        off(event: "styleSheetChanged", listener: (params: Protocol.CSS.StyleSheetChangedEvent) => void): void;
        off(event: `styleSheetChanged.${SessionId}`, listener: (params: Protocol.CSS.StyleSheetChangedEvent) => void): void;
        styleSheetChanged(sessionId?: SessionId): Promise<Protocol.CSS.StyleSheetChangedEvent>;

        /**
         * Fired whenever an active document stylesheet is removed.
         */
        on(event: "styleSheetRemoved", listener: (params: Protocol.CSS.StyleSheetRemovedEvent) => void): void;
        on(event: `styleSheetRemoved.${SessionId}`, listener: (params: Protocol.CSS.StyleSheetRemovedEvent) => void): void;
        once(event: "styleSheetRemoved", listener: (params: Protocol.CSS.StyleSheetRemovedEvent) => void): void;
        once(event: `styleSheetRemoved.${SessionId}`, listener: (params: Protocol.CSS.StyleSheetRemovedEvent) => void): void;
        off(event: "styleSheetRemoved", listener: (params: Protocol.CSS.StyleSheetRemovedEvent) => void): void;
        off(event: `styleSheetRemoved.${SessionId}`, listener: (params: Protocol.CSS.StyleSheetRemovedEvent) => void): void;
        styleSheetRemoved(sessionId?: SessionId): Promise<Protocol.CSS.StyleSheetRemovedEvent>;

    }

    export type CacheStorageApi = {
        /**
         * Deletes a cache.
         */
        deleteCache(params: Protocol.CacheStorage.DeleteCacheRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Deletes a cache entry.
         */
        deleteEntry(params: Protocol.CacheStorage.DeleteEntryRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Requests cache names.
         */
        requestCacheNames(params?: Protocol.CacheStorage.RequestCacheNamesRequest, sessionId?: SessionId): Promise<Protocol.CacheStorage.RequestCacheNamesResponse>;

        /**
         * Fetches cache entry.
         */
        requestCachedResponse(params: Protocol.CacheStorage.RequestCachedResponseRequest, sessionId?: SessionId): Promise<Protocol.CacheStorage.RequestCachedResponseResponse>;

        /**
         * Requests data from cache.
         */
        requestEntries(params: Protocol.CacheStorage.RequestEntriesRequest, sessionId?: SessionId): Promise<Protocol.CacheStorage.RequestEntriesResponse>;

    }

    export type CastApi = {
        /**
         * Starts observing for sinks that can be used for tab mirroring, and if set,
         * sinks compatible with |presentationUrl| as well. When sinks are found, a
         * |sinksUpdated| event is fired.
         * Also starts observing for issue messages. When an issue is added or removed,
         * an |issueUpdated| event is fired.
         */
        enable(params?: Protocol.Cast.EnableRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Stops observing for sinks and issues.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Sets a sink to be used when the web page requests the browser to choose a
         * sink via Presentation API, Remote Playback API, or Cast SDK.
         */
        setSinkToUse(params: Protocol.Cast.SetSinkToUseRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Starts mirroring the desktop to the sink.
         */
        startDesktopMirroring(params: Protocol.Cast.StartDesktopMirroringRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Starts mirroring the tab to the sink.
         */
        startTabMirroring(params: Protocol.Cast.StartTabMirroringRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Stops the active Cast session on the sink.
         */
        stopCasting(params: Protocol.Cast.StopCastingRequest, sessionId?: SessionId): Promise<void>;

        /**
         * This is fired whenever the list of available sinks changes. A sink is a
         * device or a software surface that you can cast to.
         */
        on(event: "sinksUpdated", listener: (params: Protocol.Cast.SinksUpdatedEvent) => void): void;
        on(event: `sinksUpdated.${SessionId}`, listener: (params: Protocol.Cast.SinksUpdatedEvent) => void): void;
        once(event: "sinksUpdated", listener: (params: Protocol.Cast.SinksUpdatedEvent) => void): void;
        once(event: `sinksUpdated.${SessionId}`, listener: (params: Protocol.Cast.SinksUpdatedEvent) => void): void;
        off(event: "sinksUpdated", listener: (params: Protocol.Cast.SinksUpdatedEvent) => void): void;
        off(event: `sinksUpdated.${SessionId}`, listener: (params: Protocol.Cast.SinksUpdatedEvent) => void): void;
        sinksUpdated(sessionId?: SessionId): Promise<Protocol.Cast.SinksUpdatedEvent>;

        /**
         * This is fired whenever the outstanding issue/error message changes.
         * |issueMessage| is empty if there is no issue.
         */
        on(event: "issueUpdated", listener: (params: Protocol.Cast.IssueUpdatedEvent) => void): void;
        on(event: `issueUpdated.${SessionId}`, listener: (params: Protocol.Cast.IssueUpdatedEvent) => void): void;
        once(event: "issueUpdated", listener: (params: Protocol.Cast.IssueUpdatedEvent) => void): void;
        once(event: `issueUpdated.${SessionId}`, listener: (params: Protocol.Cast.IssueUpdatedEvent) => void): void;
        off(event: "issueUpdated", listener: (params: Protocol.Cast.IssueUpdatedEvent) => void): void;
        off(event: `issueUpdated.${SessionId}`, listener: (params: Protocol.Cast.IssueUpdatedEvent) => void): void;
        issueUpdated(sessionId?: SessionId): Promise<Protocol.Cast.IssueUpdatedEvent>;

    }

    export type DOMApi = {
        /**
         * Collects class names for the node with given id and all of it's child nodes.
         */
        collectClassNamesFromSubtree(params: Protocol.DOM.CollectClassNamesFromSubtreeRequest, sessionId?: SessionId): Promise<Protocol.DOM.CollectClassNamesFromSubtreeResponse>;

        /**
         * Creates a deep copy of the specified node and places it into the target container before the
         * given anchor.
         */
        copyTo(params: Protocol.DOM.CopyToRequest, sessionId?: SessionId): Promise<Protocol.DOM.CopyToResponse>;

        /**
         * Describes node given its id, does not require domain to be enabled. Does not start tracking any
         * objects, can be used for automation.
         */
        describeNode(params?: Protocol.DOM.DescribeNodeRequest, sessionId?: SessionId): Promise<Protocol.DOM.DescribeNodeResponse>;

        /**
         * Scrolls the specified rect of the given node into view if not already visible.
         * Note: exactly one between nodeId, backendNodeId and objectId should be passed
         * to identify the node.
         */
        scrollIntoViewIfNeeded(params?: Protocol.DOM.ScrollIntoViewIfNeededRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Disables DOM agent for the given page.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Discards search results from the session with the given id. `getSearchResults` should no longer
         * be called for that search.
         */
        discardSearchResults(params: Protocol.DOM.DiscardSearchResultsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Enables DOM agent for the given page.
         */
        enable(params?: Protocol.DOM.EnableRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Focuses the given element.
         */
        focus(params?: Protocol.DOM.FocusRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Returns attributes for the specified node.
         */
        getAttributes(params: Protocol.DOM.GetAttributesRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetAttributesResponse>;

        /**
         * Returns boxes for the given node.
         */
        getBoxModel(params?: Protocol.DOM.GetBoxModelRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetBoxModelResponse>;

        /**
         * Returns quads that describe node position on the page. This method
         * might return multiple quads for inline nodes.
         */
        getContentQuads(params?: Protocol.DOM.GetContentQuadsRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetContentQuadsResponse>;

        /**
         * Returns the root DOM node (and optionally the subtree) to the caller.
         */
        getDocument(params?: Protocol.DOM.GetDocumentRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetDocumentResponse>;

        /**
         * Returns the root DOM node (and optionally the subtree) to the caller.
         * Deprecated, as it is not designed to work well with the rest of the DOM agent.
         * Use DOMSnapshot.captureSnapshot instead.
         */
        getFlattenedDocument(params?: Protocol.DOM.GetFlattenedDocumentRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetFlattenedDocumentResponse>;

        /**
         * Finds nodes with a given computed style in a subtree.
         */
        getNodesForSubtreeByStyle(params: Protocol.DOM.GetNodesForSubtreeByStyleRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetNodesForSubtreeByStyleResponse>;

        /**
         * Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
         * either returned or not.
         */
        getNodeForLocation(params: Protocol.DOM.GetNodeForLocationRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetNodeForLocationResponse>;

        /**
         * Returns node's HTML markup.
         */
        getOuterHTML(params?: Protocol.DOM.GetOuterHTMLRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetOuterHTMLResponse>;

        /**
         * Returns the id of the nearest ancestor that is a relayout boundary.
         */
        getRelayoutBoundary(params: Protocol.DOM.GetRelayoutBoundaryRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetRelayoutBoundaryResponse>;

        /**
         * Returns search results from given `fromIndex` to given `toIndex` from the search with the given
         * identifier.
         */
        getSearchResults(params: Protocol.DOM.GetSearchResultsRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetSearchResultsResponse>;

        /**
         * Hides any highlight.
         */
        hideHighlight(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Highlights DOM node.
         */
        highlightNode(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Highlights given rectangle.
         */
        highlightRect(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Marks last undoable state.
         */
        markUndoableState(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Moves node into the new container, places it before the given anchor.
         */
        moveTo(params: Protocol.DOM.MoveToRequest, sessionId?: SessionId): Promise<Protocol.DOM.MoveToResponse>;

        /**
         * Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
         * `cancelSearch` to end this search session.
         */
        performSearch(params: Protocol.DOM.PerformSearchRequest, sessionId?: SessionId): Promise<Protocol.DOM.PerformSearchResponse>;

        /**
         * Requests that the node is sent to the caller given its path. // FIXME, use XPath
         */
        pushNodeByPathToFrontend(params: Protocol.DOM.PushNodeByPathToFrontendRequest, sessionId?: SessionId): Promise<Protocol.DOM.PushNodeByPathToFrontendResponse>;

        /**
         * Requests that a batch of nodes is sent to the caller given their backend node ids.
         */
        pushNodesByBackendIdsToFrontend(params: Protocol.DOM.PushNodesByBackendIdsToFrontendRequest, sessionId?: SessionId): Promise<Protocol.DOM.PushNodesByBackendIdsToFrontendResponse>;

        /**
         * Executes `querySelector` on a given node.
         */
        querySelector(params: Protocol.DOM.QuerySelectorRequest, sessionId?: SessionId): Promise<Protocol.DOM.QuerySelectorResponse>;

        /**
         * Executes `querySelectorAll` on a given node.
         */
        querySelectorAll(params: Protocol.DOM.QuerySelectorAllRequest, sessionId?: SessionId): Promise<Protocol.DOM.QuerySelectorAllResponse>;

        /**
         * Returns NodeIds of current top layer elements.
         * Top layer is rendered closest to the user within a viewport, therefore its elements always
         * appear on top of all other content.
         */
        getTopLayerElements(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.DOM.GetTopLayerElementsResponse>;

        /**
         * Re-does the last undone action.
         */
        redo(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Removes attribute with given name from an element with given id.
         */
        removeAttribute(params: Protocol.DOM.RemoveAttributeRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Removes node with given id.
         */
        removeNode(params: Protocol.DOM.RemoveNodeRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Requests that children of the node with given id are returned to the caller in form of
         * `setChildNodes` events where not only immediate children are retrieved, but all children down to
         * the specified depth.
         */
        requestChildNodes(params: Protocol.DOM.RequestChildNodesRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Requests that the node is sent to the caller given the JavaScript node object reference. All
         * nodes that form the path from the node to the root are also sent to the client as a series of
         * `setChildNodes` notifications.
         */
        requestNode(params: Protocol.DOM.RequestNodeRequest, sessionId?: SessionId): Promise<Protocol.DOM.RequestNodeResponse>;

        /**
         * Resolves the JavaScript node object for a given NodeId or BackendNodeId.
         */
        resolveNode(params?: Protocol.DOM.ResolveNodeRequest, sessionId?: SessionId): Promise<Protocol.DOM.ResolveNodeResponse>;

        /**
         * Sets attribute for an element with given id.
         */
        setAttributeValue(params: Protocol.DOM.SetAttributeValueRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets attributes on element with given id. This method is useful when user edits some existing
         * attribute value and types in several attribute name/value pairs.
         */
        setAttributesAsText(params: Protocol.DOM.SetAttributesAsTextRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets files for the given file input element.
         */
        setFileInputFiles(params: Protocol.DOM.SetFileInputFilesRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.
         */
        setNodeStackTracesEnabled(params: Protocol.DOM.SetNodeStackTracesEnabledRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
         */
        getNodeStackTraces(params: Protocol.DOM.GetNodeStackTracesRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetNodeStackTracesResponse>;

        /**
         * Returns file information for the given
         * File wrapper.
         */
        getFileInfo(params: Protocol.DOM.GetFileInfoRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetFileInfoResponse>;

        /**
         * Enables console to refer to the node with given id via $x (see Command Line API for more details
         * $x functions).
         */
        setInspectedNode(params: Protocol.DOM.SetInspectedNodeRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets node name for a node with given id.
         */
        setNodeName(params: Protocol.DOM.SetNodeNameRequest, sessionId?: SessionId): Promise<Protocol.DOM.SetNodeNameResponse>;

        /**
         * Sets node value for a node with given id.
         */
        setNodeValue(params: Protocol.DOM.SetNodeValueRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets node HTML markup, returns new node id.
         */
        setOuterHTML(params: Protocol.DOM.SetOuterHTMLRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Undoes the last performed action.
         */
        undo(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Returns iframe node that owns iframe with the given domain.
         */
        getFrameOwner(params: Protocol.DOM.GetFrameOwnerRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetFrameOwnerResponse>;

        /**
         * Returns the query container of the given node based on container query
         * conditions: containerName, physical, and logical axes. If no axes are
         * provided, the style container is returned, which is the direct parent or the
         * closest element with a matching container-name.
         */
        getContainerForNode(params: Protocol.DOM.GetContainerForNodeRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetContainerForNodeResponse>;

        /**
         * Returns the descendants of a container query container that have
         * container queries against this container.
         */
        getQueryingDescendantsForContainer(params: Protocol.DOM.GetQueryingDescendantsForContainerRequest, sessionId?: SessionId): Promise<Protocol.DOM.GetQueryingDescendantsForContainerResponse>;

        /**
         * Fired when `Element`'s attribute is modified.
         */
        on(event: "attributeModified", listener: (params: Protocol.DOM.AttributeModifiedEvent) => void): void;
        on(event: `attributeModified.${SessionId}`, listener: (params: Protocol.DOM.AttributeModifiedEvent) => void): void;
        once(event: "attributeModified", listener: (params: Protocol.DOM.AttributeModifiedEvent) => void): void;
        once(event: `attributeModified.${SessionId}`, listener: (params: Protocol.DOM.AttributeModifiedEvent) => void): void;
        off(event: "attributeModified", listener: (params: Protocol.DOM.AttributeModifiedEvent) => void): void;
        off(event: `attributeModified.${SessionId}`, listener: (params: Protocol.DOM.AttributeModifiedEvent) => void): void;
        attributeModified(sessionId?: SessionId): Promise<Protocol.DOM.AttributeModifiedEvent>;

        /**
         * Fired when `Element`'s attribute is removed.
         */
        on(event: "attributeRemoved", listener: (params: Protocol.DOM.AttributeRemovedEvent) => void): void;
        on(event: `attributeRemoved.${SessionId}`, listener: (params: Protocol.DOM.AttributeRemovedEvent) => void): void;
        once(event: "attributeRemoved", listener: (params: Protocol.DOM.AttributeRemovedEvent) => void): void;
        once(event: `attributeRemoved.${SessionId}`, listener: (params: Protocol.DOM.AttributeRemovedEvent) => void): void;
        off(event: "attributeRemoved", listener: (params: Protocol.DOM.AttributeRemovedEvent) => void): void;
        off(event: `attributeRemoved.${SessionId}`, listener: (params: Protocol.DOM.AttributeRemovedEvent) => void): void;
        attributeRemoved(sessionId?: SessionId): Promise<Protocol.DOM.AttributeRemovedEvent>;

        /**
         * Mirrors `DOMCharacterDataModified` event.
         */
        on(event: "characterDataModified", listener: (params: Protocol.DOM.CharacterDataModifiedEvent) => void): void;
        on(event: `characterDataModified.${SessionId}`, listener: (params: Protocol.DOM.CharacterDataModifiedEvent) => void): void;
        once(event: "characterDataModified", listener: (params: Protocol.DOM.CharacterDataModifiedEvent) => void): void;
        once(event: `characterDataModified.${SessionId}`, listener: (params: Protocol.DOM.CharacterDataModifiedEvent) => void): void;
        off(event: "characterDataModified", listener: (params: Protocol.DOM.CharacterDataModifiedEvent) => void): void;
        off(event: `characterDataModified.${SessionId}`, listener: (params: Protocol.DOM.CharacterDataModifiedEvent) => void): void;
        characterDataModified(sessionId?: SessionId): Promise<Protocol.DOM.CharacterDataModifiedEvent>;

        /**
         * Fired when `Container`'s child node count has changed.
         */
        on(event: "childNodeCountUpdated", listener: (params: Protocol.DOM.ChildNodeCountUpdatedEvent) => void): void;
        on(event: `childNodeCountUpdated.${SessionId}`, listener: (params: Protocol.DOM.ChildNodeCountUpdatedEvent) => void): void;
        once(event: "childNodeCountUpdated", listener: (params: Protocol.DOM.ChildNodeCountUpdatedEvent) => void): void;
        once(event: `childNodeCountUpdated.${SessionId}`, listener: (params: Protocol.DOM.ChildNodeCountUpdatedEvent) => void): void;
        off(event: "childNodeCountUpdated", listener: (params: Protocol.DOM.ChildNodeCountUpdatedEvent) => void): void;
        off(event: `childNodeCountUpdated.${SessionId}`, listener: (params: Protocol.DOM.ChildNodeCountUpdatedEvent) => void): void;
        childNodeCountUpdated(sessionId?: SessionId): Promise<Protocol.DOM.ChildNodeCountUpdatedEvent>;

        /**
         * Mirrors `DOMNodeInserted` event.
         */
        on(event: "childNodeInserted", listener: (params: Protocol.DOM.ChildNodeInsertedEvent) => void): void;
        on(event: `childNodeInserted.${SessionId}`, listener: (params: Protocol.DOM.ChildNodeInsertedEvent) => void): void;
        once(event: "childNodeInserted", listener: (params: Protocol.DOM.ChildNodeInsertedEvent) => void): void;
        once(event: `childNodeInserted.${SessionId}`, listener: (params: Protocol.DOM.ChildNodeInsertedEvent) => void): void;
        off(event: "childNodeInserted", listener: (params: Protocol.DOM.ChildNodeInsertedEvent) => void): void;
        off(event: `childNodeInserted.${SessionId}`, listener: (params: Protocol.DOM.ChildNodeInsertedEvent) => void): void;
        childNodeInserted(sessionId?: SessionId): Promise<Protocol.DOM.ChildNodeInsertedEvent>;

        /**
         * Mirrors `DOMNodeRemoved` event.
         */
        on(event: "childNodeRemoved", listener: (params: Protocol.DOM.ChildNodeRemovedEvent) => void): void;
        on(event: `childNodeRemoved.${SessionId}`, listener: (params: Protocol.DOM.ChildNodeRemovedEvent) => void): void;
        once(event: "childNodeRemoved", listener: (params: Protocol.DOM.ChildNodeRemovedEvent) => void): void;
        once(event: `childNodeRemoved.${SessionId}`, listener: (params: Protocol.DOM.ChildNodeRemovedEvent) => void): void;
        off(event: "childNodeRemoved", listener: (params: Protocol.DOM.ChildNodeRemovedEvent) => void): void;
        off(event: `childNodeRemoved.${SessionId}`, listener: (params: Protocol.DOM.ChildNodeRemovedEvent) => void): void;
        childNodeRemoved(sessionId?: SessionId): Promise<Protocol.DOM.ChildNodeRemovedEvent>;

        /**
         * Called when distribution is changed.
         */
        on(event: "distributedNodesUpdated", listener: (params: Protocol.DOM.DistributedNodesUpdatedEvent) => void): void;
        on(event: `distributedNodesUpdated.${SessionId}`, listener: (params: Protocol.DOM.DistributedNodesUpdatedEvent) => void): void;
        once(event: "distributedNodesUpdated", listener: (params: Protocol.DOM.DistributedNodesUpdatedEvent) => void): void;
        once(event: `distributedNodesUpdated.${SessionId}`, listener: (params: Protocol.DOM.DistributedNodesUpdatedEvent) => void): void;
        off(event: "distributedNodesUpdated", listener: (params: Protocol.DOM.DistributedNodesUpdatedEvent) => void): void;
        off(event: `distributedNodesUpdated.${SessionId}`, listener: (params: Protocol.DOM.DistributedNodesUpdatedEvent) => void): void;
        distributedNodesUpdated(sessionId?: SessionId): Promise<Protocol.DOM.DistributedNodesUpdatedEvent>;

        /**
         * Fired when `Document` has been totally updated. Node ids are no longer valid.
         */
        on(event: "documentUpdated", listener: () => void): void;
        on(event: `documentUpdated.${SessionId}`, listener: () => void): void;
        once(event: "documentUpdated", listener: () => void): void;
        once(event: `documentUpdated.${SessionId}`, listener: () => void): void;
        off(event: "documentUpdated", listener: () => void): void;
        off(event: `documentUpdated.${SessionId}`, listener: () => void): void;
        documentUpdated(sessionId?: SessionId): Promise<void>;

        /**
         * Fired when `Element`'s inline style is modified via a CSS property modification.
         */
        on(event: "inlineStyleInvalidated", listener: (params: Protocol.DOM.InlineStyleInvalidatedEvent) => void): void;
        on(event: `inlineStyleInvalidated.${SessionId}`, listener: (params: Protocol.DOM.InlineStyleInvalidatedEvent) => void): void;
        once(event: "inlineStyleInvalidated", listener: (params: Protocol.DOM.InlineStyleInvalidatedEvent) => void): void;
        once(event: `inlineStyleInvalidated.${SessionId}`, listener: (params: Protocol.DOM.InlineStyleInvalidatedEvent) => void): void;
        off(event: "inlineStyleInvalidated", listener: (params: Protocol.DOM.InlineStyleInvalidatedEvent) => void): void;
        off(event: `inlineStyleInvalidated.${SessionId}`, listener: (params: Protocol.DOM.InlineStyleInvalidatedEvent) => void): void;
        inlineStyleInvalidated(sessionId?: SessionId): Promise<Protocol.DOM.InlineStyleInvalidatedEvent>;

        /**
         * Called when a pseudo element is added to an element.
         */
        on(event: "pseudoElementAdded", listener: (params: Protocol.DOM.PseudoElementAddedEvent) => void): void;
        on(event: `pseudoElementAdded.${SessionId}`, listener: (params: Protocol.DOM.PseudoElementAddedEvent) => void): void;
        once(event: "pseudoElementAdded", listener: (params: Protocol.DOM.PseudoElementAddedEvent) => void): void;
        once(event: `pseudoElementAdded.${SessionId}`, listener: (params: Protocol.DOM.PseudoElementAddedEvent) => void): void;
        off(event: "pseudoElementAdded", listener: (params: Protocol.DOM.PseudoElementAddedEvent) => void): void;
        off(event: `pseudoElementAdded.${SessionId}`, listener: (params: Protocol.DOM.PseudoElementAddedEvent) => void): void;
        pseudoElementAdded(sessionId?: SessionId): Promise<Protocol.DOM.PseudoElementAddedEvent>;

        /**
         * Called when top layer elements are changed.
         */
        on(event: "topLayerElementsUpdated", listener: () => void): void;
        on(event: `topLayerElementsUpdated.${SessionId}`, listener: () => void): void;
        once(event: "topLayerElementsUpdated", listener: () => void): void;
        once(event: `topLayerElementsUpdated.${SessionId}`, listener: () => void): void;
        off(event: "topLayerElementsUpdated", listener: () => void): void;
        off(event: `topLayerElementsUpdated.${SessionId}`, listener: () => void): void;
        topLayerElementsUpdated(sessionId?: SessionId): Promise<void>;

        /**
         * Called when a pseudo element is removed from an element.
         */
        on(event: "pseudoElementRemoved", listener: (params: Protocol.DOM.PseudoElementRemovedEvent) => void): void;
        on(event: `pseudoElementRemoved.${SessionId}`, listener: (params: Protocol.DOM.PseudoElementRemovedEvent) => void): void;
        once(event: "pseudoElementRemoved", listener: (params: Protocol.DOM.PseudoElementRemovedEvent) => void): void;
        once(event: `pseudoElementRemoved.${SessionId}`, listener: (params: Protocol.DOM.PseudoElementRemovedEvent) => void): void;
        off(event: "pseudoElementRemoved", listener: (params: Protocol.DOM.PseudoElementRemovedEvent) => void): void;
        off(event: `pseudoElementRemoved.${SessionId}`, listener: (params: Protocol.DOM.PseudoElementRemovedEvent) => void): void;
        pseudoElementRemoved(sessionId?: SessionId): Promise<Protocol.DOM.PseudoElementRemovedEvent>;

        /**
         * Fired when backend wants to provide client with the missing DOM structure. This happens upon
         * most of the calls requesting node ids.
         */
        on(event: "setChildNodes", listener: (params: Protocol.DOM.SetChildNodesEvent) => void): void;
        on(event: `setChildNodes.${SessionId}`, listener: (params: Protocol.DOM.SetChildNodesEvent) => void): void;
        once(event: "setChildNodes", listener: (params: Protocol.DOM.SetChildNodesEvent) => void): void;
        once(event: `setChildNodes.${SessionId}`, listener: (params: Protocol.DOM.SetChildNodesEvent) => void): void;
        off(event: "setChildNodes", listener: (params: Protocol.DOM.SetChildNodesEvent) => void): void;
        off(event: `setChildNodes.${SessionId}`, listener: (params: Protocol.DOM.SetChildNodesEvent) => void): void;
        setChildNodes(sessionId?: SessionId): Promise<Protocol.DOM.SetChildNodesEvent>;

        /**
         * Called when shadow root is popped from the element.
         */
        on(event: "shadowRootPopped", listener: (params: Protocol.DOM.ShadowRootPoppedEvent) => void): void;
        on(event: `shadowRootPopped.${SessionId}`, listener: (params: Protocol.DOM.ShadowRootPoppedEvent) => void): void;
        once(event: "shadowRootPopped", listener: (params: Protocol.DOM.ShadowRootPoppedEvent) => void): void;
        once(event: `shadowRootPopped.${SessionId}`, listener: (params: Protocol.DOM.ShadowRootPoppedEvent) => void): void;
        off(event: "shadowRootPopped", listener: (params: Protocol.DOM.ShadowRootPoppedEvent) => void): void;
        off(event: `shadowRootPopped.${SessionId}`, listener: (params: Protocol.DOM.ShadowRootPoppedEvent) => void): void;
        shadowRootPopped(sessionId?: SessionId): Promise<Protocol.DOM.ShadowRootPoppedEvent>;

        /**
         * Called when shadow root is pushed into the element.
         */
        on(event: "shadowRootPushed", listener: (params: Protocol.DOM.ShadowRootPushedEvent) => void): void;
        on(event: `shadowRootPushed.${SessionId}`, listener: (params: Protocol.DOM.ShadowRootPushedEvent) => void): void;
        once(event: "shadowRootPushed", listener: (params: Protocol.DOM.ShadowRootPushedEvent) => void): void;
        once(event: `shadowRootPushed.${SessionId}`, listener: (params: Protocol.DOM.ShadowRootPushedEvent) => void): void;
        off(event: "shadowRootPushed", listener: (params: Protocol.DOM.ShadowRootPushedEvent) => void): void;
        off(event: `shadowRootPushed.${SessionId}`, listener: (params: Protocol.DOM.ShadowRootPushedEvent) => void): void;
        shadowRootPushed(sessionId?: SessionId): Promise<Protocol.DOM.ShadowRootPushedEvent>;

    }

    export type DOMDebuggerApi = {
        /**
         * Returns event listeners of the given object.
         */
        getEventListeners(params: Protocol.DOMDebugger.GetEventListenersRequest, sessionId?: SessionId): Promise<Protocol.DOMDebugger.GetEventListenersResponse>;

        /**
         * Removes DOM breakpoint that was set using `setDOMBreakpoint`.
         */
        removeDOMBreakpoint(params: Protocol.DOMDebugger.RemoveDOMBreakpointRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Removes breakpoint on particular DOM event.
         */
        removeEventListenerBreakpoint(params: Protocol.DOMDebugger.RemoveEventListenerBreakpointRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Removes breakpoint on particular native event.
         */
        removeInstrumentationBreakpoint(params: Protocol.DOMDebugger.RemoveInstrumentationBreakpointRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Removes breakpoint from XMLHttpRequest.
         */
        removeXHRBreakpoint(params: Protocol.DOMDebugger.RemoveXHRBreakpointRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets breakpoint on particular CSP violations.
         */
        setBreakOnCSPViolation(params: Protocol.DOMDebugger.SetBreakOnCSPViolationRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets breakpoint on particular operation with DOM.
         */
        setDOMBreakpoint(params: Protocol.DOMDebugger.SetDOMBreakpointRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets breakpoint on particular DOM event.
         */
        setEventListenerBreakpoint(params: Protocol.DOMDebugger.SetEventListenerBreakpointRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets breakpoint on particular native event.
         */
        setInstrumentationBreakpoint(params: Protocol.DOMDebugger.SetInstrumentationBreakpointRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets breakpoint on XMLHttpRequest.
         */
        setXHRBreakpoint(params: Protocol.DOMDebugger.SetXHRBreakpointRequest, sessionId?: SessionId): Promise<void>;

    }

    export type EventBreakpointsApi = {
        /**
         * Sets breakpoint on particular native event.
         */
        setInstrumentationBreakpoint(params: Protocol.EventBreakpoints.SetInstrumentationBreakpointRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Removes breakpoint on particular native event.
         */
        removeInstrumentationBreakpoint(params: Protocol.EventBreakpoints.RemoveInstrumentationBreakpointRequest, sessionId?: SessionId): Promise<void>;

    }

    export type DOMSnapshotApi = {
        /**
         * Disables DOM snapshot agent for the given page.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables DOM snapshot agent for the given page.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Returns a document snapshot, including the full DOM tree of the root node (including iframes,
         * template contents, and imported documents) in a flattened array, as well as layout and
         * white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
         * flattened.
         */
        getSnapshot(params: Protocol.DOMSnapshot.GetSnapshotRequest, sessionId?: SessionId): Promise<Protocol.DOMSnapshot.GetSnapshotResponse>;

        /**
         * Returns a document snapshot, including the full DOM tree of the root node (including iframes,
         * template contents, and imported documents) in a flattened array, as well as layout and
         * white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
         * flattened.
         */
        captureSnapshot(params: Protocol.DOMSnapshot.CaptureSnapshotRequest, sessionId?: SessionId): Promise<Protocol.DOMSnapshot.CaptureSnapshotResponse>;

    }

    export type DOMStorageApi = {
        clear(params: Protocol.DOMStorage.ClearRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Disables storage tracking, prevents storage events from being sent to the client.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables storage tracking, storage events will now be delivered to the client.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        getDOMStorageItems(params: Protocol.DOMStorage.GetDOMStorageItemsRequest, sessionId?: SessionId): Promise<Protocol.DOMStorage.GetDOMStorageItemsResponse>;

        removeDOMStorageItem(params: Protocol.DOMStorage.RemoveDOMStorageItemRequest, sessionId?: SessionId): Promise<void>;

        setDOMStorageItem(params: Protocol.DOMStorage.SetDOMStorageItemRequest, sessionId?: SessionId): Promise<void>;

        on(event: "domStorageItemAdded", listener: (params: Protocol.DOMStorage.DomStorageItemAddedEvent) => void): void;
        on(event: `domStorageItemAdded.${SessionId}`, listener: (params: Protocol.DOMStorage.DomStorageItemAddedEvent) => void): void;
        once(event: "domStorageItemAdded", listener: (params: Protocol.DOMStorage.DomStorageItemAddedEvent) => void): void;
        once(event: `domStorageItemAdded.${SessionId}`, listener: (params: Protocol.DOMStorage.DomStorageItemAddedEvent) => void): void;
        off(event: "domStorageItemAdded", listener: (params: Protocol.DOMStorage.DomStorageItemAddedEvent) => void): void;
        off(event: `domStorageItemAdded.${SessionId}`, listener: (params: Protocol.DOMStorage.DomStorageItemAddedEvent) => void): void;
        domStorageItemAdded(sessionId?: SessionId): Promise<Protocol.DOMStorage.DomStorageItemAddedEvent>;

        on(event: "domStorageItemRemoved", listener: (params: Protocol.DOMStorage.DomStorageItemRemovedEvent) => void): void;
        on(event: `domStorageItemRemoved.${SessionId}`, listener: (params: Protocol.DOMStorage.DomStorageItemRemovedEvent) => void): void;
        once(event: "domStorageItemRemoved", listener: (params: Protocol.DOMStorage.DomStorageItemRemovedEvent) => void): void;
        once(event: `domStorageItemRemoved.${SessionId}`, listener: (params: Protocol.DOMStorage.DomStorageItemRemovedEvent) => void): void;
        off(event: "domStorageItemRemoved", listener: (params: Protocol.DOMStorage.DomStorageItemRemovedEvent) => void): void;
        off(event: `domStorageItemRemoved.${SessionId}`, listener: (params: Protocol.DOMStorage.DomStorageItemRemovedEvent) => void): void;
        domStorageItemRemoved(sessionId?: SessionId): Promise<Protocol.DOMStorage.DomStorageItemRemovedEvent>;

        on(event: "domStorageItemUpdated", listener: (params: Protocol.DOMStorage.DomStorageItemUpdatedEvent) => void): void;
        on(event: `domStorageItemUpdated.${SessionId}`, listener: (params: Protocol.DOMStorage.DomStorageItemUpdatedEvent) => void): void;
        once(event: "domStorageItemUpdated", listener: (params: Protocol.DOMStorage.DomStorageItemUpdatedEvent) => void): void;
        once(event: `domStorageItemUpdated.${SessionId}`, listener: (params: Protocol.DOMStorage.DomStorageItemUpdatedEvent) => void): void;
        off(event: "domStorageItemUpdated", listener: (params: Protocol.DOMStorage.DomStorageItemUpdatedEvent) => void): void;
        off(event: `domStorageItemUpdated.${SessionId}`, listener: (params: Protocol.DOMStorage.DomStorageItemUpdatedEvent) => void): void;
        domStorageItemUpdated(sessionId?: SessionId): Promise<Protocol.DOMStorage.DomStorageItemUpdatedEvent>;

        on(event: "domStorageItemsCleared", listener: (params: Protocol.DOMStorage.DomStorageItemsClearedEvent) => void): void;
        on(event: `domStorageItemsCleared.${SessionId}`, listener: (params: Protocol.DOMStorage.DomStorageItemsClearedEvent) => void): void;
        once(event: "domStorageItemsCleared", listener: (params: Protocol.DOMStorage.DomStorageItemsClearedEvent) => void): void;
        once(event: `domStorageItemsCleared.${SessionId}`, listener: (params: Protocol.DOMStorage.DomStorageItemsClearedEvent) => void): void;
        off(event: "domStorageItemsCleared", listener: (params: Protocol.DOMStorage.DomStorageItemsClearedEvent) => void): void;
        off(event: `domStorageItemsCleared.${SessionId}`, listener: (params: Protocol.DOMStorage.DomStorageItemsClearedEvent) => void): void;
        domStorageItemsCleared(sessionId?: SessionId): Promise<Protocol.DOMStorage.DomStorageItemsClearedEvent>;

    }

    export type DatabaseApi = {
        /**
         * Disables database tracking, prevents database events from being sent to the client.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables database tracking, database events will now be delivered to the client.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        executeSQL(params: Protocol.Database.ExecuteSQLRequest, sessionId?: SessionId): Promise<Protocol.Database.ExecuteSQLResponse>;

        getDatabaseTableNames(params: Protocol.Database.GetDatabaseTableNamesRequest, sessionId?: SessionId): Promise<Protocol.Database.GetDatabaseTableNamesResponse>;

        on(event: "addDatabase", listener: (params: Protocol.Database.AddDatabaseEvent) => void): void;
        on(event: `addDatabase.${SessionId}`, listener: (params: Protocol.Database.AddDatabaseEvent) => void): void;
        once(event: "addDatabase", listener: (params: Protocol.Database.AddDatabaseEvent) => void): void;
        once(event: `addDatabase.${SessionId}`, listener: (params: Protocol.Database.AddDatabaseEvent) => void): void;
        off(event: "addDatabase", listener: (params: Protocol.Database.AddDatabaseEvent) => void): void;
        off(event: `addDatabase.${SessionId}`, listener: (params: Protocol.Database.AddDatabaseEvent) => void): void;
        addDatabase(sessionId?: SessionId): Promise<Protocol.Database.AddDatabaseEvent>;

    }

    export type DeviceOrientationApi = {
        /**
         * Clears the overridden Device Orientation.
         */
        clearDeviceOrientationOverride(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Overrides the Device Orientation.
         */
        setDeviceOrientationOverride(params: Protocol.DeviceOrientation.SetDeviceOrientationOverrideRequest, sessionId?: SessionId): Promise<void>;

    }

    export type EmulationApi = {
        /**
         * Tells whether emulation is supported.
         */
        canEmulate(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Emulation.CanEmulateResponse>;

        /**
         * Clears the overridden device metrics.
         */
        clearDeviceMetricsOverride(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Clears the overridden Geolocation Position and Error.
         */
        clearGeolocationOverride(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Requests that page scale factor is reset to initial values.
         */
        resetPageScaleFactor(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables or disables simulating a focused and active page.
         */
        setFocusEmulationEnabled(params: Protocol.Emulation.SetFocusEmulationEnabledRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Automatically render all web contents using a dark theme.
         */
        setAutoDarkModeOverride(params?: Protocol.Emulation.SetAutoDarkModeOverrideRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Enables CPU throttling to emulate slow CPUs.
         */
        setCPUThrottlingRate(params: Protocol.Emulation.SetCPUThrottlingRateRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets or clears an override of the default background color of the frame. This override is used
         * if the content does not specify one.
         */
        setDefaultBackgroundColorOverride(params?: Protocol.Emulation.SetDefaultBackgroundColorOverrideRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
         * window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
         * query results).
         */
        setDeviceMetricsOverride(params: Protocol.Emulation.SetDeviceMetricsOverrideRequest, sessionId?: SessionId): Promise<void>;

        setScrollbarsHidden(params: Protocol.Emulation.SetScrollbarsHiddenRequest, sessionId?: SessionId): Promise<void>;

        setDocumentCookieDisabled(params: Protocol.Emulation.SetDocumentCookieDisabledRequest, sessionId?: SessionId): Promise<void>;

        setEmitTouchEventsForMouse(params: Protocol.Emulation.SetEmitTouchEventsForMouseRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Emulates the given media type or media feature for CSS media queries.
         */
        setEmulatedMedia(params?: Protocol.Emulation.SetEmulatedMediaRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Emulates the given vision deficiency.
         */
        setEmulatedVisionDeficiency(params: Protocol.Emulation.SetEmulatedVisionDeficiencyRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
         * unavailable.
         */
        setGeolocationOverride(params?: Protocol.Emulation.SetGeolocationOverrideRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Overrides the Idle state.
         */
        setIdleOverride(params: Protocol.Emulation.SetIdleOverrideRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Clears Idle state overrides.
         */
        clearIdleOverride(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Overrides value returned by the javascript navigator object.
         */
        setNavigatorOverrides(params: Protocol.Emulation.SetNavigatorOverridesRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets a specified page scale factor.
         */
        setPageScaleFactor(params: Protocol.Emulation.SetPageScaleFactorRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Switches script execution in the page.
         */
        setScriptExecutionDisabled(params: Protocol.Emulation.SetScriptExecutionDisabledRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Enables touch on platforms which do not support them.
         */
        setTouchEmulationEnabled(params: Protocol.Emulation.SetTouchEmulationEnabledRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
         * the current virtual time policy.  Note this supersedes any previous time budget.
         */
        setVirtualTimePolicy(params: Protocol.Emulation.SetVirtualTimePolicyRequest, sessionId?: SessionId): Promise<Protocol.Emulation.SetVirtualTimePolicyResponse>;

        /**
         * Overrides default host system locale with the specified one.
         */
        setLocaleOverride(params?: Protocol.Emulation.SetLocaleOverrideRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Overrides default host system timezone with the specified one.
         */
        setTimezoneOverride(params: Protocol.Emulation.SetTimezoneOverrideRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Resizes the frame/viewport of the page. Note that this does not affect the frame's container
         * (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
         * on Android.
         */
        setVisibleSize(params: Protocol.Emulation.SetVisibleSizeRequest, sessionId?: SessionId): Promise<void>;

        setDisabledImageTypes(params: Protocol.Emulation.SetDisabledImageTypesRequest, sessionId?: SessionId): Promise<void>;

        setHardwareConcurrencyOverride(params: Protocol.Emulation.SetHardwareConcurrencyOverrideRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Allows overriding user agent with the given string.
         */
        setUserAgentOverride(params: Protocol.Emulation.SetUserAgentOverrideRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Allows overriding the automation flag.
         */
        setAutomationOverride(params: Protocol.Emulation.SetAutomationOverrideRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.
         */
        on(event: "virtualTimeBudgetExpired", listener: () => void): void;
        on(event: `virtualTimeBudgetExpired.${SessionId}`, listener: () => void): void;
        once(event: "virtualTimeBudgetExpired", listener: () => void): void;
        once(event: `virtualTimeBudgetExpired.${SessionId}`, listener: () => void): void;
        off(event: "virtualTimeBudgetExpired", listener: () => void): void;
        off(event: `virtualTimeBudgetExpired.${SessionId}`, listener: () => void): void;
        virtualTimeBudgetExpired(sessionId?: SessionId): Promise<void>;

    }

    export type HeadlessExperimentalApi = {
        /**
         * Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
         * screenshot from the resulting frame. Requires that the target was created with enabled
         * BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
         * https://goo.gle/chrome-headless-rendering for more background.
         */
        beginFrame(params?: Protocol.HeadlessExperimental.BeginFrameRequest, sessionId?: SessionId): Promise<Protocol.HeadlessExperimental.BeginFrameResponse>;

        /**
         * Disables headless events for the target.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables headless events for the target.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

    }

    export type IOApi = {
        /**
         * Close the stream, discard any temporary backing storage.
         */
        close(params: Protocol.IO.CloseRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Read a chunk of the stream
         */
        read(params: Protocol.IO.ReadRequest, sessionId?: SessionId): Promise<Protocol.IO.ReadResponse>;

        /**
         * Return UUID of Blob object specified by a remote object id.
         */
        resolveBlob(params: Protocol.IO.ResolveBlobRequest, sessionId?: SessionId): Promise<Protocol.IO.ResolveBlobResponse>;

    }

    export type IndexedDBApi = {
        /**
         * Clears all entries from an object store.
         */
        clearObjectStore(params: Protocol.IndexedDB.ClearObjectStoreRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Deletes a database.
         */
        deleteDatabase(params: Protocol.IndexedDB.DeleteDatabaseRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Delete a range of entries from an object store
         */
        deleteObjectStoreEntries(params: Protocol.IndexedDB.DeleteObjectStoreEntriesRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Disables events from backend.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables events from backend.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Requests data from object store or index.
         */
        requestData(params: Protocol.IndexedDB.RequestDataRequest, sessionId?: SessionId): Promise<Protocol.IndexedDB.RequestDataResponse>;

        /**
         * Gets metadata of an object store
         */
        getMetadata(params: Protocol.IndexedDB.GetMetadataRequest, sessionId?: SessionId): Promise<Protocol.IndexedDB.GetMetadataResponse>;

        /**
         * Requests database with given name in given frame.
         */
        requestDatabase(params: Protocol.IndexedDB.RequestDatabaseRequest, sessionId?: SessionId): Promise<Protocol.IndexedDB.RequestDatabaseResponse>;

        /**
         * Requests database names for given security origin.
         */
        requestDatabaseNames(params?: Protocol.IndexedDB.RequestDatabaseNamesRequest, sessionId?: SessionId): Promise<Protocol.IndexedDB.RequestDatabaseNamesResponse>;

    }

    export type InputApi = {
        /**
         * Dispatches a drag event into the page.
         */
        dispatchDragEvent(params: Protocol.Input.DispatchDragEventRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Dispatches a key event to the page.
         */
        dispatchKeyEvent(params: Protocol.Input.DispatchKeyEventRequest, sessionId?: SessionId): Promise<void>;

        /**
         * This method emulates inserting text that doesn't come from a key press,
         * for example an emoji keyboard or an IME.
         */
        insertText(params: Protocol.Input.InsertTextRequest, sessionId?: SessionId): Promise<void>;

        /**
         * This method sets the current candidate text for ime.
         * Use imeCommitComposition to commit the final text.
         * Use imeSetComposition with empty string as text to cancel composition.
         */
        imeSetComposition(params: Protocol.Input.ImeSetCompositionRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Dispatches a mouse event to the page.
         */
        dispatchMouseEvent(params: Protocol.Input.DispatchMouseEventRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Dispatches a touch event to the page.
         */
        dispatchTouchEvent(params: Protocol.Input.DispatchTouchEventRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Emulates touch event from the mouse event parameters.
         */
        emulateTouchFromMouseEvent(params: Protocol.Input.EmulateTouchFromMouseEventRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Ignores input events (useful while auditing page).
         */
        setIgnoreInputEvents(params: Protocol.Input.SetIgnoreInputEventsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.
         * Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`.
         */
        setInterceptDrags(params: Protocol.Input.SetInterceptDragsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
         */
        synthesizePinchGesture(params: Protocol.Input.SynthesizePinchGestureRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
         */
        synthesizeScrollGesture(params: Protocol.Input.SynthesizeScrollGestureRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Synthesizes a tap gesture over a time period by issuing appropriate touch events.
         */
        synthesizeTapGesture(params: Protocol.Input.SynthesizeTapGestureRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Emitted only when `Input.setInterceptDrags` is enabled. Use this data with `Input.dispatchDragEvent` to
         * restore normal drag and drop behavior.
         */
        on(event: "dragIntercepted", listener: (params: Protocol.Input.DragInterceptedEvent) => void): void;
        on(event: `dragIntercepted.${SessionId}`, listener: (params: Protocol.Input.DragInterceptedEvent) => void): void;
        once(event: "dragIntercepted", listener: (params: Protocol.Input.DragInterceptedEvent) => void): void;
        once(event: `dragIntercepted.${SessionId}`, listener: (params: Protocol.Input.DragInterceptedEvent) => void): void;
        off(event: "dragIntercepted", listener: (params: Protocol.Input.DragInterceptedEvent) => void): void;
        off(event: `dragIntercepted.${SessionId}`, listener: (params: Protocol.Input.DragInterceptedEvent) => void): void;
        dragIntercepted(sessionId?: SessionId): Promise<Protocol.Input.DragInterceptedEvent>;

    }

    export type InspectorApi = {
        /**
         * Disables inspector domain notifications.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables inspector domain notifications.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Fired when remote debugging connection is about to be terminated. Contains detach reason.
         */
        on(event: "detached", listener: (params: Protocol.Inspector.DetachedEvent) => void): void;
        on(event: `detached.${SessionId}`, listener: (params: Protocol.Inspector.DetachedEvent) => void): void;
        once(event: "detached", listener: (params: Protocol.Inspector.DetachedEvent) => void): void;
        once(event: `detached.${SessionId}`, listener: (params: Protocol.Inspector.DetachedEvent) => void): void;
        off(event: "detached", listener: (params: Protocol.Inspector.DetachedEvent) => void): void;
        off(event: `detached.${SessionId}`, listener: (params: Protocol.Inspector.DetachedEvent) => void): void;
        detached(sessionId?: SessionId): Promise<Protocol.Inspector.DetachedEvent>;

        /**
         * Fired when debugging target has crashed
         */
        on(event: "targetCrashed", listener: () => void): void;
        on(event: `targetCrashed.${SessionId}`, listener: () => void): void;
        once(event: "targetCrashed", listener: () => void): void;
        once(event: `targetCrashed.${SessionId}`, listener: () => void): void;
        off(event: "targetCrashed", listener: () => void): void;
        off(event: `targetCrashed.${SessionId}`, listener: () => void): void;
        targetCrashed(sessionId?: SessionId): Promise<void>;

        /**
         * Fired when debugging target has reloaded after crash
         */
        on(event: "targetReloadedAfterCrash", listener: () => void): void;
        on(event: `targetReloadedAfterCrash.${SessionId}`, listener: () => void): void;
        once(event: "targetReloadedAfterCrash", listener: () => void): void;
        once(event: `targetReloadedAfterCrash.${SessionId}`, listener: () => void): void;
        off(event: "targetReloadedAfterCrash", listener: () => void): void;
        off(event: `targetReloadedAfterCrash.${SessionId}`, listener: () => void): void;
        targetReloadedAfterCrash(sessionId?: SessionId): Promise<void>;

    }

    export type LayerTreeApi = {
        /**
         * Provides the reasons why the given layer was composited.
         */
        compositingReasons(params: Protocol.LayerTree.CompositingReasonsRequest, sessionId?: SessionId): Promise<Protocol.LayerTree.CompositingReasonsResponse>;

        /**
         * Disables compositing tree inspection.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables compositing tree inspection.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Returns the snapshot identifier.
         */
        loadSnapshot(params: Protocol.LayerTree.LoadSnapshotRequest, sessionId?: SessionId): Promise<Protocol.LayerTree.LoadSnapshotResponse>;

        /**
         * Returns the layer snapshot identifier.
         */
        makeSnapshot(params: Protocol.LayerTree.MakeSnapshotRequest, sessionId?: SessionId): Promise<Protocol.LayerTree.MakeSnapshotResponse>;

        profileSnapshot(params: Protocol.LayerTree.ProfileSnapshotRequest, sessionId?: SessionId): Promise<Protocol.LayerTree.ProfileSnapshotResponse>;

        /**
         * Releases layer snapshot captured by the back-end.
         */
        releaseSnapshot(params: Protocol.LayerTree.ReleaseSnapshotRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Replays the layer snapshot and returns the resulting bitmap.
         */
        replaySnapshot(params: Protocol.LayerTree.ReplaySnapshotRequest, sessionId?: SessionId): Promise<Protocol.LayerTree.ReplaySnapshotResponse>;

        /**
         * Replays the layer snapshot and returns canvas log.
         */
        snapshotCommandLog(params: Protocol.LayerTree.SnapshotCommandLogRequest, sessionId?: SessionId): Promise<Protocol.LayerTree.SnapshotCommandLogResponse>;

        on(event: "layerPainted", listener: (params: Protocol.LayerTree.LayerPaintedEvent) => void): void;
        on(event: `layerPainted.${SessionId}`, listener: (params: Protocol.LayerTree.LayerPaintedEvent) => void): void;
        once(event: "layerPainted", listener: (params: Protocol.LayerTree.LayerPaintedEvent) => void): void;
        once(event: `layerPainted.${SessionId}`, listener: (params: Protocol.LayerTree.LayerPaintedEvent) => void): void;
        off(event: "layerPainted", listener: (params: Protocol.LayerTree.LayerPaintedEvent) => void): void;
        off(event: `layerPainted.${SessionId}`, listener: (params: Protocol.LayerTree.LayerPaintedEvent) => void): void;
        layerPainted(sessionId?: SessionId): Promise<Protocol.LayerTree.LayerPaintedEvent>;

        on(event: "layerTreeDidChange", listener: (params: Protocol.LayerTree.LayerTreeDidChangeEvent) => void): void;
        on(event: `layerTreeDidChange.${SessionId}`, listener: (params: Protocol.LayerTree.LayerTreeDidChangeEvent) => void): void;
        once(event: "layerTreeDidChange", listener: (params: Protocol.LayerTree.LayerTreeDidChangeEvent) => void): void;
        once(event: `layerTreeDidChange.${SessionId}`, listener: (params: Protocol.LayerTree.LayerTreeDidChangeEvent) => void): void;
        off(event: "layerTreeDidChange", listener: (params: Protocol.LayerTree.LayerTreeDidChangeEvent) => void): void;
        off(event: `layerTreeDidChange.${SessionId}`, listener: (params: Protocol.LayerTree.LayerTreeDidChangeEvent) => void): void;
        layerTreeDidChange(sessionId?: SessionId): Promise<Protocol.LayerTree.LayerTreeDidChangeEvent>;

    }

    export type LogApi = {
        /**
         * Clears the log.
         */
        clear(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Disables log domain, prevents further log entries from being reported to the client.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables log domain, sends the entries collected so far to the client by means of the
         * `entryAdded` notification.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * start violation reporting.
         */
        startViolationsReport(params: Protocol.Log.StartViolationsReportRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Stop violation reporting.
         */
        stopViolationsReport(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Issued when new message was logged.
         */
        on(event: "entryAdded", listener: (params: Protocol.Log.EntryAddedEvent) => void): void;
        on(event: `entryAdded.${SessionId}`, listener: (params: Protocol.Log.EntryAddedEvent) => void): void;
        once(event: "entryAdded", listener: (params: Protocol.Log.EntryAddedEvent) => void): void;
        once(event: `entryAdded.${SessionId}`, listener: (params: Protocol.Log.EntryAddedEvent) => void): void;
        off(event: "entryAdded", listener: (params: Protocol.Log.EntryAddedEvent) => void): void;
        off(event: `entryAdded.${SessionId}`, listener: (params: Protocol.Log.EntryAddedEvent) => void): void;
        entryAdded(sessionId?: SessionId): Promise<Protocol.Log.EntryAddedEvent>;

    }

    export type MemoryApi = {
        getDOMCounters(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Memory.GetDOMCountersResponse>;

        prepareForLeakDetection(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Simulate OomIntervention by purging V8 memory.
         */
        forciblyPurgeJavaScriptMemory(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enable/disable suppressing memory pressure notifications in all processes.
         */
        setPressureNotificationsSuppressed(params: Protocol.Memory.SetPressureNotificationsSuppressedRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Simulate a memory pressure notification in all processes.
         */
        simulatePressureNotification(params: Protocol.Memory.SimulatePressureNotificationRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Start collecting native memory profile.
         */
        startSampling(params?: Protocol.Memory.StartSamplingRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Stop collecting native memory profile.
         */
        stopSampling(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Retrieve native memory allocations profile
         * collected since renderer process startup.
         */
        getAllTimeSamplingProfile(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Memory.GetAllTimeSamplingProfileResponse>;

        /**
         * Retrieve native memory allocations profile
         * collected since browser process startup.
         */
        getBrowserSamplingProfile(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Memory.GetBrowserSamplingProfileResponse>;

        /**
         * Retrieve native memory allocations profile collected since last
         * `startSampling` call.
         */
        getSamplingProfile(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Memory.GetSamplingProfileResponse>;

    }

    export type NetworkApi = {
        /**
         * Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.
         */
        setAcceptedEncodings(params: Protocol.Network.SetAcceptedEncodingsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Clears accepted encodings set by setAcceptedEncodings
         */
        clearAcceptedEncodingsOverride(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Tells whether clearing browser cache is supported.
         */
        canClearBrowserCache(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Network.CanClearBrowserCacheResponse>;

        /**
         * Tells whether clearing browser cookies is supported.
         */
        canClearBrowserCookies(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Network.CanClearBrowserCookiesResponse>;

        /**
         * Tells whether emulation of network conditions is supported.
         */
        canEmulateNetworkConditions(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Network.CanEmulateNetworkConditionsResponse>;

        /**
         * Clears browser cache.
         */
        clearBrowserCache(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Clears browser cookies.
         */
        clearBrowserCookies(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Response to Network.requestIntercepted which either modifies the request to continue with any
         * modifications, or blocks it, or completes it with the provided response bytes. If a network
         * fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
         * event will be sent with the same InterceptionId.
         * Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.
         */
        continueInterceptedRequest(params: Protocol.Network.ContinueInterceptedRequestRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Deletes browser cookies with matching name and url or domain/path pair.
         */
        deleteCookies(params: Protocol.Network.DeleteCookiesRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Disables network tracking, prevents network events from being sent to the client.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Activates emulation of network conditions.
         */
        emulateNetworkConditions(params: Protocol.Network.EmulateNetworkConditionsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Enables network tracking, network events will now be delivered to the client.
         */
        enable(params?: Protocol.Network.EnableRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Returns all browser cookies. Depending on the backend support, will return detailed cookie
         * information in the `cookies` field.
         */
        getAllCookies(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Network.GetAllCookiesResponse>;

        /**
         * Returns the DER-encoded certificate.
         */
        getCertificate(params: Protocol.Network.GetCertificateRequest, sessionId?: SessionId): Promise<Protocol.Network.GetCertificateResponse>;

        /**
         * Returns all browser cookies for the current URL. Depending on the backend support, will return
         * detailed cookie information in the `cookies` field.
         */
        getCookies(params?: Protocol.Network.GetCookiesRequest, sessionId?: SessionId): Promise<Protocol.Network.GetCookiesResponse>;

        /**
         * Returns content served for the given request.
         */
        getResponseBody(params: Protocol.Network.GetResponseBodyRequest, sessionId?: SessionId): Promise<Protocol.Network.GetResponseBodyResponse>;

        /**
         * Returns post data sent with the request. Returns an error when no data was sent with the request.
         */
        getRequestPostData(params: Protocol.Network.GetRequestPostDataRequest, sessionId?: SessionId): Promise<Protocol.Network.GetRequestPostDataResponse>;

        /**
         * Returns content served for the given currently intercepted request.
         */
        getResponseBodyForInterception(params: Protocol.Network.GetResponseBodyForInterceptionRequest, sessionId?: SessionId): Promise<Protocol.Network.GetResponseBodyForInterceptionResponse>;

        /**
         * Returns a handle to the stream representing the response body. Note that after this command,
         * the intercepted request can't be continued as is -- you either need to cancel it or to provide
         * the response body. The stream only supports sequential read, IO.read will fail if the position
         * is specified.
         */
        takeResponseBodyForInterceptionAsStream(params: Protocol.Network.TakeResponseBodyForInterceptionAsStreamRequest, sessionId?: SessionId): Promise<Protocol.Network.TakeResponseBodyForInterceptionAsStreamResponse>;

        /**
         * This method sends a new XMLHttpRequest which is identical to the original one. The following
         * parameters should be identical: method, url, async, request body, extra headers, withCredentials
         * attribute, user, password.
         */
        replayXHR(params: Protocol.Network.ReplayXHRRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Searches for given string in response content.
         */
        searchInResponseBody(params: Protocol.Network.SearchInResponseBodyRequest, sessionId?: SessionId): Promise<Protocol.Network.SearchInResponseBodyResponse>;

        /**
         * Blocks URLs from loading.
         */
        setBlockedURLs(params: Protocol.Network.SetBlockedURLsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Toggles ignoring of service worker for each request.
         */
        setBypassServiceWorker(params: Protocol.Network.SetBypassServiceWorkerRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Toggles ignoring cache for each request. If `true`, cache will not be used.
         */
        setCacheDisabled(params: Protocol.Network.SetCacheDisabledRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
         */
        setCookie(params: Protocol.Network.SetCookieRequest, sessionId?: SessionId): Promise<Protocol.Network.SetCookieResponse>;

        /**
         * Sets given cookies.
         */
        setCookies(params: Protocol.Network.SetCookiesRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Specifies whether to always send extra HTTP headers with the requests from this page.
         */
        setExtraHTTPHeaders(params: Protocol.Network.SetExtraHTTPHeadersRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Specifies whether to attach a page script stack id in requests
         */
        setAttachDebugStack(params: Protocol.Network.SetAttachDebugStackRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets the requests to intercept that match the provided patterns and optionally resource types.
         * Deprecated, please use Fetch.enable instead.
         */
        setRequestInterception(params: Protocol.Network.SetRequestInterceptionRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Allows overriding user agent with the given string.
         */
        setUserAgentOverride(params: Protocol.Network.SetUserAgentOverrideRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Returns information about the COEP/COOP isolation status.
         */
        getSecurityIsolationStatus(params?: Protocol.Network.GetSecurityIsolationStatusRequest, sessionId?: SessionId): Promise<Protocol.Network.GetSecurityIsolationStatusResponse>;

        /**
         * Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
         * Enabling triggers 'reportingApiReportAdded' for all existing reports.
         */
        enableReportingApi(params: Protocol.Network.EnableReportingApiRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Fetches the resource and returns the content.
         */
        loadNetworkResource(params: Protocol.Network.LoadNetworkResourceRequest, sessionId?: SessionId): Promise<Protocol.Network.LoadNetworkResourceResponse>;

        /**
         * Fired when data chunk was received over the network.
         */
        on(event: "dataReceived", listener: (params: Protocol.Network.DataReceivedEvent) => void): void;
        on(event: `dataReceived.${SessionId}`, listener: (params: Protocol.Network.DataReceivedEvent) => void): void;
        once(event: "dataReceived", listener: (params: Protocol.Network.DataReceivedEvent) => void): void;
        once(event: `dataReceived.${SessionId}`, listener: (params: Protocol.Network.DataReceivedEvent) => void): void;
        off(event: "dataReceived", listener: (params: Protocol.Network.DataReceivedEvent) => void): void;
        off(event: `dataReceived.${SessionId}`, listener: (params: Protocol.Network.DataReceivedEvent) => void): void;
        dataReceived(sessionId?: SessionId): Promise<Protocol.Network.DataReceivedEvent>;

        /**
         * Fired when EventSource message is received.
         */
        on(event: "eventSourceMessageReceived", listener: (params: Protocol.Network.EventSourceMessageReceivedEvent) => void): void;
        on(event: `eventSourceMessageReceived.${SessionId}`, listener: (params: Protocol.Network.EventSourceMessageReceivedEvent) => void): void;
        once(event: "eventSourceMessageReceived", listener: (params: Protocol.Network.EventSourceMessageReceivedEvent) => void): void;
        once(event: `eventSourceMessageReceived.${SessionId}`, listener: (params: Protocol.Network.EventSourceMessageReceivedEvent) => void): void;
        off(event: "eventSourceMessageReceived", listener: (params: Protocol.Network.EventSourceMessageReceivedEvent) => void): void;
        off(event: `eventSourceMessageReceived.${SessionId}`, listener: (params: Protocol.Network.EventSourceMessageReceivedEvent) => void): void;
        eventSourceMessageReceived(sessionId?: SessionId): Promise<Protocol.Network.EventSourceMessageReceivedEvent>;

        /**
         * Fired when HTTP request has failed to load.
         */
        on(event: "loadingFailed", listener: (params: Protocol.Network.LoadingFailedEvent) => void): void;
        on(event: `loadingFailed.${SessionId}`, listener: (params: Protocol.Network.LoadingFailedEvent) => void): void;
        once(event: "loadingFailed", listener: (params: Protocol.Network.LoadingFailedEvent) => void): void;
        once(event: `loadingFailed.${SessionId}`, listener: (params: Protocol.Network.LoadingFailedEvent) => void): void;
        off(event: "loadingFailed", listener: (params: Protocol.Network.LoadingFailedEvent) => void): void;
        off(event: `loadingFailed.${SessionId}`, listener: (params: Protocol.Network.LoadingFailedEvent) => void): void;
        loadingFailed(sessionId?: SessionId): Promise<Protocol.Network.LoadingFailedEvent>;

        /**
         * Fired when HTTP request has finished loading.
         */
        on(event: "loadingFinished", listener: (params: Protocol.Network.LoadingFinishedEvent) => void): void;
        on(event: `loadingFinished.${SessionId}`, listener: (params: Protocol.Network.LoadingFinishedEvent) => void): void;
        once(event: "loadingFinished", listener: (params: Protocol.Network.LoadingFinishedEvent) => void): void;
        once(event: `loadingFinished.${SessionId}`, listener: (params: Protocol.Network.LoadingFinishedEvent) => void): void;
        off(event: "loadingFinished", listener: (params: Protocol.Network.LoadingFinishedEvent) => void): void;
        off(event: `loadingFinished.${SessionId}`, listener: (params: Protocol.Network.LoadingFinishedEvent) => void): void;
        loadingFinished(sessionId?: SessionId): Promise<Protocol.Network.LoadingFinishedEvent>;

        /**
         * Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
         * mocked.
         * Deprecated, use Fetch.requestPaused instead.
         */
        on(event: "requestIntercepted", listener: (params: Protocol.Network.RequestInterceptedEvent) => void): void;
        on(event: `requestIntercepted.${SessionId}`, listener: (params: Protocol.Network.RequestInterceptedEvent) => void): void;
        once(event: "requestIntercepted", listener: (params: Protocol.Network.RequestInterceptedEvent) => void): void;
        once(event: `requestIntercepted.${SessionId}`, listener: (params: Protocol.Network.RequestInterceptedEvent) => void): void;
        off(event: "requestIntercepted", listener: (params: Protocol.Network.RequestInterceptedEvent) => void): void;
        off(event: `requestIntercepted.${SessionId}`, listener: (params: Protocol.Network.RequestInterceptedEvent) => void): void;
        requestIntercepted(sessionId?: SessionId): Promise<Protocol.Network.RequestInterceptedEvent>;

        /**
         * Fired if request ended up loading from cache.
         */
        on(event: "requestServedFromCache", listener: (params: Protocol.Network.RequestServedFromCacheEvent) => void): void;
        on(event: `requestServedFromCache.${SessionId}`, listener: (params: Protocol.Network.RequestServedFromCacheEvent) => void): void;
        once(event: "requestServedFromCache", listener: (params: Protocol.Network.RequestServedFromCacheEvent) => void): void;
        once(event: `requestServedFromCache.${SessionId}`, listener: (params: Protocol.Network.RequestServedFromCacheEvent) => void): void;
        off(event: "requestServedFromCache", listener: (params: Protocol.Network.RequestServedFromCacheEvent) => void): void;
        off(event: `requestServedFromCache.${SessionId}`, listener: (params: Protocol.Network.RequestServedFromCacheEvent) => void): void;
        requestServedFromCache(sessionId?: SessionId): Promise<Protocol.Network.RequestServedFromCacheEvent>;

        /**
         * Fired when page is about to send HTTP request.
         */
        on(event: "requestWillBeSent", listener: (params: Protocol.Network.RequestWillBeSentEvent) => void): void;
        on(event: `requestWillBeSent.${SessionId}`, listener: (params: Protocol.Network.RequestWillBeSentEvent) => void): void;
        once(event: "requestWillBeSent", listener: (params: Protocol.Network.RequestWillBeSentEvent) => void): void;
        once(event: `requestWillBeSent.${SessionId}`, listener: (params: Protocol.Network.RequestWillBeSentEvent) => void): void;
        off(event: "requestWillBeSent", listener: (params: Protocol.Network.RequestWillBeSentEvent) => void): void;
        off(event: `requestWillBeSent.${SessionId}`, listener: (params: Protocol.Network.RequestWillBeSentEvent) => void): void;
        requestWillBeSent(sessionId?: SessionId): Promise<Protocol.Network.RequestWillBeSentEvent>;

        /**
         * Fired when resource loading priority is changed
         */
        on(event: "resourceChangedPriority", listener: (params: Protocol.Network.ResourceChangedPriorityEvent) => void): void;
        on(event: `resourceChangedPriority.${SessionId}`, listener: (params: Protocol.Network.ResourceChangedPriorityEvent) => void): void;
        once(event: "resourceChangedPriority", listener: (params: Protocol.Network.ResourceChangedPriorityEvent) => void): void;
        once(event: `resourceChangedPriority.${SessionId}`, listener: (params: Protocol.Network.ResourceChangedPriorityEvent) => void): void;
        off(event: "resourceChangedPriority", listener: (params: Protocol.Network.ResourceChangedPriorityEvent) => void): void;
        off(event: `resourceChangedPriority.${SessionId}`, listener: (params: Protocol.Network.ResourceChangedPriorityEvent) => void): void;
        resourceChangedPriority(sessionId?: SessionId): Promise<Protocol.Network.ResourceChangedPriorityEvent>;

        /**
         * Fired when a signed exchange was received over the network
         */
        on(event: "signedExchangeReceived", listener: (params: Protocol.Network.SignedExchangeReceivedEvent) => void): void;
        on(event: `signedExchangeReceived.${SessionId}`, listener: (params: Protocol.Network.SignedExchangeReceivedEvent) => void): void;
        once(event: "signedExchangeReceived", listener: (params: Protocol.Network.SignedExchangeReceivedEvent) => void): void;
        once(event: `signedExchangeReceived.${SessionId}`, listener: (params: Protocol.Network.SignedExchangeReceivedEvent) => void): void;
        off(event: "signedExchangeReceived", listener: (params: Protocol.Network.SignedExchangeReceivedEvent) => void): void;
        off(event: `signedExchangeReceived.${SessionId}`, listener: (params: Protocol.Network.SignedExchangeReceivedEvent) => void): void;
        signedExchangeReceived(sessionId?: SessionId): Promise<Protocol.Network.SignedExchangeReceivedEvent>;

        /**
         * Fired when HTTP response is available.
         */
        on(event: "responseReceived", listener: (params: Protocol.Network.ResponseReceivedEvent) => void): void;
        on(event: `responseReceived.${SessionId}`, listener: (params: Protocol.Network.ResponseReceivedEvent) => void): void;
        once(event: "responseReceived", listener: (params: Protocol.Network.ResponseReceivedEvent) => void): void;
        once(event: `responseReceived.${SessionId}`, listener: (params: Protocol.Network.ResponseReceivedEvent) => void): void;
        off(event: "responseReceived", listener: (params: Protocol.Network.ResponseReceivedEvent) => void): void;
        off(event: `responseReceived.${SessionId}`, listener: (params: Protocol.Network.ResponseReceivedEvent) => void): void;
        responseReceived(sessionId?: SessionId): Promise<Protocol.Network.ResponseReceivedEvent>;

        /**
         * Fired when WebSocket is closed.
         */
        on(event: "webSocketClosed", listener: (params: Protocol.Network.WebSocketClosedEvent) => void): void;
        on(event: `webSocketClosed.${SessionId}`, listener: (params: Protocol.Network.WebSocketClosedEvent) => void): void;
        once(event: "webSocketClosed", listener: (params: Protocol.Network.WebSocketClosedEvent) => void): void;
        once(event: `webSocketClosed.${SessionId}`, listener: (params: Protocol.Network.WebSocketClosedEvent) => void): void;
        off(event: "webSocketClosed", listener: (params: Protocol.Network.WebSocketClosedEvent) => void): void;
        off(event: `webSocketClosed.${SessionId}`, listener: (params: Protocol.Network.WebSocketClosedEvent) => void): void;
        webSocketClosed(sessionId?: SessionId): Promise<Protocol.Network.WebSocketClosedEvent>;

        /**
         * Fired upon WebSocket creation.
         */
        on(event: "webSocketCreated", listener: (params: Protocol.Network.WebSocketCreatedEvent) => void): void;
        on(event: `webSocketCreated.${SessionId}`, listener: (params: Protocol.Network.WebSocketCreatedEvent) => void): void;
        once(event: "webSocketCreated", listener: (params: Protocol.Network.WebSocketCreatedEvent) => void): void;
        once(event: `webSocketCreated.${SessionId}`, listener: (params: Protocol.Network.WebSocketCreatedEvent) => void): void;
        off(event: "webSocketCreated", listener: (params: Protocol.Network.WebSocketCreatedEvent) => void): void;
        off(event: `webSocketCreated.${SessionId}`, listener: (params: Protocol.Network.WebSocketCreatedEvent) => void): void;
        webSocketCreated(sessionId?: SessionId): Promise<Protocol.Network.WebSocketCreatedEvent>;

        /**
         * Fired when WebSocket message error occurs.
         */
        on(event: "webSocketFrameError", listener: (params: Protocol.Network.WebSocketFrameErrorEvent) => void): void;
        on(event: `webSocketFrameError.${SessionId}`, listener: (params: Protocol.Network.WebSocketFrameErrorEvent) => void): void;
        once(event: "webSocketFrameError", listener: (params: Protocol.Network.WebSocketFrameErrorEvent) => void): void;
        once(event: `webSocketFrameError.${SessionId}`, listener: (params: Protocol.Network.WebSocketFrameErrorEvent) => void): void;
        off(event: "webSocketFrameError", listener: (params: Protocol.Network.WebSocketFrameErrorEvent) => void): void;
        off(event: `webSocketFrameError.${SessionId}`, listener: (params: Protocol.Network.WebSocketFrameErrorEvent) => void): void;
        webSocketFrameError(sessionId?: SessionId): Promise<Protocol.Network.WebSocketFrameErrorEvent>;

        /**
         * Fired when WebSocket message is received.
         */
        on(event: "webSocketFrameReceived", listener: (params: Protocol.Network.WebSocketFrameReceivedEvent) => void): void;
        on(event: `webSocketFrameReceived.${SessionId}`, listener: (params: Protocol.Network.WebSocketFrameReceivedEvent) => void): void;
        once(event: "webSocketFrameReceived", listener: (params: Protocol.Network.WebSocketFrameReceivedEvent) => void): void;
        once(event: `webSocketFrameReceived.${SessionId}`, listener: (params: Protocol.Network.WebSocketFrameReceivedEvent) => void): void;
        off(event: "webSocketFrameReceived", listener: (params: Protocol.Network.WebSocketFrameReceivedEvent) => void): void;
        off(event: `webSocketFrameReceived.${SessionId}`, listener: (params: Protocol.Network.WebSocketFrameReceivedEvent) => void): void;
        webSocketFrameReceived(sessionId?: SessionId): Promise<Protocol.Network.WebSocketFrameReceivedEvent>;

        /**
         * Fired when WebSocket message is sent.
         */
        on(event: "webSocketFrameSent", listener: (params: Protocol.Network.WebSocketFrameSentEvent) => void): void;
        on(event: `webSocketFrameSent.${SessionId}`, listener: (params: Protocol.Network.WebSocketFrameSentEvent) => void): void;
        once(event: "webSocketFrameSent", listener: (params: Protocol.Network.WebSocketFrameSentEvent) => void): void;
        once(event: `webSocketFrameSent.${SessionId}`, listener: (params: Protocol.Network.WebSocketFrameSentEvent) => void): void;
        off(event: "webSocketFrameSent", listener: (params: Protocol.Network.WebSocketFrameSentEvent) => void): void;
        off(event: `webSocketFrameSent.${SessionId}`, listener: (params: Protocol.Network.WebSocketFrameSentEvent) => void): void;
        webSocketFrameSent(sessionId?: SessionId): Promise<Protocol.Network.WebSocketFrameSentEvent>;

        /**
         * Fired when WebSocket handshake response becomes available.
         */
        on(event: "webSocketHandshakeResponseReceived", listener: (params: Protocol.Network.WebSocketHandshakeResponseReceivedEvent) => void): void;
        on(event: `webSocketHandshakeResponseReceived.${SessionId}`, listener: (params: Protocol.Network.WebSocketHandshakeResponseReceivedEvent) => void): void;
        once(event: "webSocketHandshakeResponseReceived", listener: (params: Protocol.Network.WebSocketHandshakeResponseReceivedEvent) => void): void;
        once(event: `webSocketHandshakeResponseReceived.${SessionId}`, listener: (params: Protocol.Network.WebSocketHandshakeResponseReceivedEvent) => void): void;
        off(event: "webSocketHandshakeResponseReceived", listener: (params: Protocol.Network.WebSocketHandshakeResponseReceivedEvent) => void): void;
        off(event: `webSocketHandshakeResponseReceived.${SessionId}`, listener: (params: Protocol.Network.WebSocketHandshakeResponseReceivedEvent) => void): void;
        webSocketHandshakeResponseReceived(sessionId?: SessionId): Promise<Protocol.Network.WebSocketHandshakeResponseReceivedEvent>;

        /**
         * Fired when WebSocket is about to initiate handshake.
         */
        on(event: "webSocketWillSendHandshakeRequest", listener: (params: Protocol.Network.WebSocketWillSendHandshakeRequestEvent) => void): void;
        on(event: `webSocketWillSendHandshakeRequest.${SessionId}`, listener: (params: Protocol.Network.WebSocketWillSendHandshakeRequestEvent) => void): void;
        once(event: "webSocketWillSendHandshakeRequest", listener: (params: Protocol.Network.WebSocketWillSendHandshakeRequestEvent) => void): void;
        once(event: `webSocketWillSendHandshakeRequest.${SessionId}`, listener: (params: Protocol.Network.WebSocketWillSendHandshakeRequestEvent) => void): void;
        off(event: "webSocketWillSendHandshakeRequest", listener: (params: Protocol.Network.WebSocketWillSendHandshakeRequestEvent) => void): void;
        off(event: `webSocketWillSendHandshakeRequest.${SessionId}`, listener: (params: Protocol.Network.WebSocketWillSendHandshakeRequestEvent) => void): void;
        webSocketWillSendHandshakeRequest(sessionId?: SessionId): Promise<Protocol.Network.WebSocketWillSendHandshakeRequestEvent>;

        /**
         * Fired upon WebTransport creation.
         */
        on(event: "webTransportCreated", listener: (params: Protocol.Network.WebTransportCreatedEvent) => void): void;
        on(event: `webTransportCreated.${SessionId}`, listener: (params: Protocol.Network.WebTransportCreatedEvent) => void): void;
        once(event: "webTransportCreated", listener: (params: Protocol.Network.WebTransportCreatedEvent) => void): void;
        once(event: `webTransportCreated.${SessionId}`, listener: (params: Protocol.Network.WebTransportCreatedEvent) => void): void;
        off(event: "webTransportCreated", listener: (params: Protocol.Network.WebTransportCreatedEvent) => void): void;
        off(event: `webTransportCreated.${SessionId}`, listener: (params: Protocol.Network.WebTransportCreatedEvent) => void): void;
        webTransportCreated(sessionId?: SessionId): Promise<Protocol.Network.WebTransportCreatedEvent>;

        /**
         * Fired when WebTransport handshake is finished.
         */
        on(event: "webTransportConnectionEstablished", listener: (params: Protocol.Network.WebTransportConnectionEstablishedEvent) => void): void;
        on(event: `webTransportConnectionEstablished.${SessionId}`, listener: (params: Protocol.Network.WebTransportConnectionEstablishedEvent) => void): void;
        once(event: "webTransportConnectionEstablished", listener: (params: Protocol.Network.WebTransportConnectionEstablishedEvent) => void): void;
        once(event: `webTransportConnectionEstablished.${SessionId}`, listener: (params: Protocol.Network.WebTransportConnectionEstablishedEvent) => void): void;
        off(event: "webTransportConnectionEstablished", listener: (params: Protocol.Network.WebTransportConnectionEstablishedEvent) => void): void;
        off(event: `webTransportConnectionEstablished.${SessionId}`, listener: (params: Protocol.Network.WebTransportConnectionEstablishedEvent) => void): void;
        webTransportConnectionEstablished(sessionId?: SessionId): Promise<Protocol.Network.WebTransportConnectionEstablishedEvent>;

        /**
         * Fired when WebTransport is disposed.
         */
        on(event: "webTransportClosed", listener: (params: Protocol.Network.WebTransportClosedEvent) => void): void;
        on(event: `webTransportClosed.${SessionId}`, listener: (params: Protocol.Network.WebTransportClosedEvent) => void): void;
        once(event: "webTransportClosed", listener: (params: Protocol.Network.WebTransportClosedEvent) => void): void;
        once(event: `webTransportClosed.${SessionId}`, listener: (params: Protocol.Network.WebTransportClosedEvent) => void): void;
        off(event: "webTransportClosed", listener: (params: Protocol.Network.WebTransportClosedEvent) => void): void;
        off(event: `webTransportClosed.${SessionId}`, listener: (params: Protocol.Network.WebTransportClosedEvent) => void): void;
        webTransportClosed(sessionId?: SessionId): Promise<Protocol.Network.WebTransportClosedEvent>;

        /**
         * Fired when additional information about a requestWillBeSent event is available from the
         * network stack. Not every requestWillBeSent event will have an additional
         * requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent
         * or requestWillBeSentExtraInfo will be fired first for the same request.
         */
        on(event: "requestWillBeSentExtraInfo", listener: (params: Protocol.Network.RequestWillBeSentExtraInfoEvent) => void): void;
        on(event: `requestWillBeSentExtraInfo.${SessionId}`, listener: (params: Protocol.Network.RequestWillBeSentExtraInfoEvent) => void): void;
        once(event: "requestWillBeSentExtraInfo", listener: (params: Protocol.Network.RequestWillBeSentExtraInfoEvent) => void): void;
        once(event: `requestWillBeSentExtraInfo.${SessionId}`, listener: (params: Protocol.Network.RequestWillBeSentExtraInfoEvent) => void): void;
        off(event: "requestWillBeSentExtraInfo", listener: (params: Protocol.Network.RequestWillBeSentExtraInfoEvent) => void): void;
        off(event: `requestWillBeSentExtraInfo.${SessionId}`, listener: (params: Protocol.Network.RequestWillBeSentExtraInfoEvent) => void): void;
        requestWillBeSentExtraInfo(sessionId?: SessionId): Promise<Protocol.Network.RequestWillBeSentExtraInfoEvent>;

        /**
         * Fired when additional information about a responseReceived event is available from the network
         * stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for
         * it, and responseReceivedExtraInfo may be fired before or after responseReceived.
         */
        on(event: "responseReceivedExtraInfo", listener: (params: Protocol.Network.ResponseReceivedExtraInfoEvent) => void): void;
        on(event: `responseReceivedExtraInfo.${SessionId}`, listener: (params: Protocol.Network.ResponseReceivedExtraInfoEvent) => void): void;
        once(event: "responseReceivedExtraInfo", listener: (params: Protocol.Network.ResponseReceivedExtraInfoEvent) => void): void;
        once(event: `responseReceivedExtraInfo.${SessionId}`, listener: (params: Protocol.Network.ResponseReceivedExtraInfoEvent) => void): void;
        off(event: "responseReceivedExtraInfo", listener: (params: Protocol.Network.ResponseReceivedExtraInfoEvent) => void): void;
        off(event: `responseReceivedExtraInfo.${SessionId}`, listener: (params: Protocol.Network.ResponseReceivedExtraInfoEvent) => void): void;
        responseReceivedExtraInfo(sessionId?: SessionId): Promise<Protocol.Network.ResponseReceivedExtraInfoEvent>;

        /**
         * Fired exactly once for each Trust Token operation. Depending on
         * the type of the operation and whether the operation succeeded or
         * failed, the event is fired before the corresponding request was sent
         * or after the response was received.
         */
        on(event: "trustTokenOperationDone", listener: (params: Protocol.Network.TrustTokenOperationDoneEvent) => void): void;
        on(event: `trustTokenOperationDone.${SessionId}`, listener: (params: Protocol.Network.TrustTokenOperationDoneEvent) => void): void;
        once(event: "trustTokenOperationDone", listener: (params: Protocol.Network.TrustTokenOperationDoneEvent) => void): void;
        once(event: `trustTokenOperationDone.${SessionId}`, listener: (params: Protocol.Network.TrustTokenOperationDoneEvent) => void): void;
        off(event: "trustTokenOperationDone", listener: (params: Protocol.Network.TrustTokenOperationDoneEvent) => void): void;
        off(event: `trustTokenOperationDone.${SessionId}`, listener: (params: Protocol.Network.TrustTokenOperationDoneEvent) => void): void;
        trustTokenOperationDone(sessionId?: SessionId): Promise<Protocol.Network.TrustTokenOperationDoneEvent>;

        /**
         * Fired once when parsing the .wbn file has succeeded.
         * The event contains the information about the web bundle contents.
         */
        on(event: "subresourceWebBundleMetadataReceived", listener: (params: Protocol.Network.SubresourceWebBundleMetadataReceivedEvent) => void): void;
        on(event: `subresourceWebBundleMetadataReceived.${SessionId}`, listener: (params: Protocol.Network.SubresourceWebBundleMetadataReceivedEvent) => void): void;
        once(event: "subresourceWebBundleMetadataReceived", listener: (params: Protocol.Network.SubresourceWebBundleMetadataReceivedEvent) => void): void;
        once(event: `subresourceWebBundleMetadataReceived.${SessionId}`, listener: (params: Protocol.Network.SubresourceWebBundleMetadataReceivedEvent) => void): void;
        off(event: "subresourceWebBundleMetadataReceived", listener: (params: Protocol.Network.SubresourceWebBundleMetadataReceivedEvent) => void): void;
        off(event: `subresourceWebBundleMetadataReceived.${SessionId}`, listener: (params: Protocol.Network.SubresourceWebBundleMetadataReceivedEvent) => void): void;
        subresourceWebBundleMetadataReceived(sessionId?: SessionId): Promise<Protocol.Network.SubresourceWebBundleMetadataReceivedEvent>;

        /**
         * Fired once when parsing the .wbn file has failed.
         */
        on(event: "subresourceWebBundleMetadataError", listener: (params: Protocol.Network.SubresourceWebBundleMetadataErrorEvent) => void): void;
        on(event: `subresourceWebBundleMetadataError.${SessionId}`, listener: (params: Protocol.Network.SubresourceWebBundleMetadataErrorEvent) => void): void;
        once(event: "subresourceWebBundleMetadataError", listener: (params: Protocol.Network.SubresourceWebBundleMetadataErrorEvent) => void): void;
        once(event: `subresourceWebBundleMetadataError.${SessionId}`, listener: (params: Protocol.Network.SubresourceWebBundleMetadataErrorEvent) => void): void;
        off(event: "subresourceWebBundleMetadataError", listener: (params: Protocol.Network.SubresourceWebBundleMetadataErrorEvent) => void): void;
        off(event: `subresourceWebBundleMetadataError.${SessionId}`, listener: (params: Protocol.Network.SubresourceWebBundleMetadataErrorEvent) => void): void;
        subresourceWebBundleMetadataError(sessionId?: SessionId): Promise<Protocol.Network.SubresourceWebBundleMetadataErrorEvent>;

        /**
         * Fired when handling requests for resources within a .wbn file.
         * Note: this will only be fired for resources that are requested by the webpage.
         */
        on(event: "subresourceWebBundleInnerResponseParsed", listener: (params: Protocol.Network.SubresourceWebBundleInnerResponseParsedEvent) => void): void;
        on(event: `subresourceWebBundleInnerResponseParsed.${SessionId}`, listener: (params: Protocol.Network.SubresourceWebBundleInnerResponseParsedEvent) => void): void;
        once(event: "subresourceWebBundleInnerResponseParsed", listener: (params: Protocol.Network.SubresourceWebBundleInnerResponseParsedEvent) => void): void;
        once(event: `subresourceWebBundleInnerResponseParsed.${SessionId}`, listener: (params: Protocol.Network.SubresourceWebBundleInnerResponseParsedEvent) => void): void;
        off(event: "subresourceWebBundleInnerResponseParsed", listener: (params: Protocol.Network.SubresourceWebBundleInnerResponseParsedEvent) => void): void;
        off(event: `subresourceWebBundleInnerResponseParsed.${SessionId}`, listener: (params: Protocol.Network.SubresourceWebBundleInnerResponseParsedEvent) => void): void;
        subresourceWebBundleInnerResponseParsed(sessionId?: SessionId): Promise<Protocol.Network.SubresourceWebBundleInnerResponseParsedEvent>;

        /**
         * Fired when request for resources within a .wbn file failed.
         */
        on(event: "subresourceWebBundleInnerResponseError", listener: (params: Protocol.Network.SubresourceWebBundleInnerResponseErrorEvent) => void): void;
        on(event: `subresourceWebBundleInnerResponseError.${SessionId}`, listener: (params: Protocol.Network.SubresourceWebBundleInnerResponseErrorEvent) => void): void;
        once(event: "subresourceWebBundleInnerResponseError", listener: (params: Protocol.Network.SubresourceWebBundleInnerResponseErrorEvent) => void): void;
        once(event: `subresourceWebBundleInnerResponseError.${SessionId}`, listener: (params: Protocol.Network.SubresourceWebBundleInnerResponseErrorEvent) => void): void;
        off(event: "subresourceWebBundleInnerResponseError", listener: (params: Protocol.Network.SubresourceWebBundleInnerResponseErrorEvent) => void): void;
        off(event: `subresourceWebBundleInnerResponseError.${SessionId}`, listener: (params: Protocol.Network.SubresourceWebBundleInnerResponseErrorEvent) => void): void;
        subresourceWebBundleInnerResponseError(sessionId?: SessionId): Promise<Protocol.Network.SubresourceWebBundleInnerResponseErrorEvent>;

        /**
         * Is sent whenever a new report is added.
         * And after 'enableReportingApi' for all existing reports.
         */
        on(event: "reportingApiReportAdded", listener: (params: Protocol.Network.ReportingApiReportAddedEvent) => void): void;
        on(event: `reportingApiReportAdded.${SessionId}`, listener: (params: Protocol.Network.ReportingApiReportAddedEvent) => void): void;
        once(event: "reportingApiReportAdded", listener: (params: Protocol.Network.ReportingApiReportAddedEvent) => void): void;
        once(event: `reportingApiReportAdded.${SessionId}`, listener: (params: Protocol.Network.ReportingApiReportAddedEvent) => void): void;
        off(event: "reportingApiReportAdded", listener: (params: Protocol.Network.ReportingApiReportAddedEvent) => void): void;
        off(event: `reportingApiReportAdded.${SessionId}`, listener: (params: Protocol.Network.ReportingApiReportAddedEvent) => void): void;
        reportingApiReportAdded(sessionId?: SessionId): Promise<Protocol.Network.ReportingApiReportAddedEvent>;

        on(event: "reportingApiReportUpdated", listener: (params: Protocol.Network.ReportingApiReportUpdatedEvent) => void): void;
        on(event: `reportingApiReportUpdated.${SessionId}`, listener: (params: Protocol.Network.ReportingApiReportUpdatedEvent) => void): void;
        once(event: "reportingApiReportUpdated", listener: (params: Protocol.Network.ReportingApiReportUpdatedEvent) => void): void;
        once(event: `reportingApiReportUpdated.${SessionId}`, listener: (params: Protocol.Network.ReportingApiReportUpdatedEvent) => void): void;
        off(event: "reportingApiReportUpdated", listener: (params: Protocol.Network.ReportingApiReportUpdatedEvent) => void): void;
        off(event: `reportingApiReportUpdated.${SessionId}`, listener: (params: Protocol.Network.ReportingApiReportUpdatedEvent) => void): void;
        reportingApiReportUpdated(sessionId?: SessionId): Promise<Protocol.Network.ReportingApiReportUpdatedEvent>;

        on(event: "reportingApiEndpointsChangedForOrigin", listener: (params: Protocol.Network.ReportingApiEndpointsChangedForOriginEvent) => void): void;
        on(event: `reportingApiEndpointsChangedForOrigin.${SessionId}`, listener: (params: Protocol.Network.ReportingApiEndpointsChangedForOriginEvent) => void): void;
        once(event: "reportingApiEndpointsChangedForOrigin", listener: (params: Protocol.Network.ReportingApiEndpointsChangedForOriginEvent) => void): void;
        once(event: `reportingApiEndpointsChangedForOrigin.${SessionId}`, listener: (params: Protocol.Network.ReportingApiEndpointsChangedForOriginEvent) => void): void;
        off(event: "reportingApiEndpointsChangedForOrigin", listener: (params: Protocol.Network.ReportingApiEndpointsChangedForOriginEvent) => void): void;
        off(event: `reportingApiEndpointsChangedForOrigin.${SessionId}`, listener: (params: Protocol.Network.ReportingApiEndpointsChangedForOriginEvent) => void): void;
        reportingApiEndpointsChangedForOrigin(sessionId?: SessionId): Promise<Protocol.Network.ReportingApiEndpointsChangedForOriginEvent>;

    }

    export type OverlayApi = {
        /**
         * Disables domain notifications.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables domain notifications.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * For testing.
         */
        getHighlightObjectForTest(params: Protocol.Overlay.GetHighlightObjectForTestRequest, sessionId?: SessionId): Promise<Protocol.Overlay.GetHighlightObjectForTestResponse>;

        /**
         * For Persistent Grid testing.
         */
        getGridHighlightObjectsForTest(params: Protocol.Overlay.GetGridHighlightObjectsForTestRequest, sessionId?: SessionId): Promise<Protocol.Overlay.GetGridHighlightObjectsForTestResponse>;

        /**
         * For Source Order Viewer testing.
         */
        getSourceOrderHighlightObjectForTest(params: Protocol.Overlay.GetSourceOrderHighlightObjectForTestRequest, sessionId?: SessionId): Promise<Protocol.Overlay.GetSourceOrderHighlightObjectForTestResponse>;

        /**
         * Hides any highlight.
         */
        hideHighlight(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Highlights owner element of the frame with given id.
         * Deprecated: Doesn't work reliablity and cannot be fixed due to process
         * separatation (the owner node might be in a different process). Determine
         * the owner node in the client and use highlightNode.
         */
        highlightFrame(params: Protocol.Overlay.HighlightFrameRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
         * objectId must be specified.
         */
        highlightNode(params: Protocol.Overlay.HighlightNodeRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
         */
        highlightQuad(params: Protocol.Overlay.HighlightQuadRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
         */
        highlightRect(params: Protocol.Overlay.HighlightRectRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Highlights the source order of the children of the DOM node with given id or with the given
         * JavaScript object wrapper. Either nodeId or objectId must be specified.
         */
        highlightSourceOrder(params: Protocol.Overlay.HighlightSourceOrderRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
         * Backend then generates 'inspectNodeRequested' event upon element selection.
         */
        setInspectMode(params: Protocol.Overlay.SetInspectModeRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Highlights owner element of all frames detected to be ads.
         */
        setShowAdHighlights(params: Protocol.Overlay.SetShowAdHighlightsRequest, sessionId?: SessionId): Promise<void>;

        setPausedInDebuggerMessage(params?: Protocol.Overlay.SetPausedInDebuggerMessageRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Requests that backend shows debug borders on layers
         */
        setShowDebugBorders(params: Protocol.Overlay.SetShowDebugBordersRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Requests that backend shows the FPS counter
         */
        setShowFPSCounter(params: Protocol.Overlay.SetShowFPSCounterRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Highlight multiple elements with the CSS Grid overlay.
         */
        setShowGridOverlays(params: Protocol.Overlay.SetShowGridOverlaysRequest, sessionId?: SessionId): Promise<void>;

        setShowFlexOverlays(params: Protocol.Overlay.SetShowFlexOverlaysRequest, sessionId?: SessionId): Promise<void>;

        setShowScrollSnapOverlays(params: Protocol.Overlay.SetShowScrollSnapOverlaysRequest, sessionId?: SessionId): Promise<void>;

        setShowContainerQueryOverlays(params: Protocol.Overlay.SetShowContainerQueryOverlaysRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Requests that backend shows paint rectangles
         */
        setShowPaintRects(params: Protocol.Overlay.SetShowPaintRectsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Requests that backend shows layout shift regions
         */
        setShowLayoutShiftRegions(params: Protocol.Overlay.SetShowLayoutShiftRegionsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Requests that backend shows scroll bottleneck rects
         */
        setShowScrollBottleneckRects(params: Protocol.Overlay.SetShowScrollBottleneckRectsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Deprecated, no longer has any effect.
         */
        setShowHitTestBorders(params: Protocol.Overlay.SetShowHitTestBordersRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Request that backend shows an overlay with web vital metrics.
         */
        setShowWebVitals(params: Protocol.Overlay.SetShowWebVitalsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Paints viewport size upon main frame resize.
         */
        setShowViewportSizeOnResize(params: Protocol.Overlay.SetShowViewportSizeOnResizeRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Add a dual screen device hinge
         */
        setShowHinge(params?: Protocol.Overlay.SetShowHingeRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Show elements in isolation mode with overlays.
         */
        setShowIsolatedElements(params: Protocol.Overlay.SetShowIsolatedElementsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Fired when the node should be inspected. This happens after call to `setInspectMode` or when
         * user manually inspects an element.
         */
        on(event: "inspectNodeRequested", listener: (params: Protocol.Overlay.InspectNodeRequestedEvent) => void): void;
        on(event: `inspectNodeRequested.${SessionId}`, listener: (params: Protocol.Overlay.InspectNodeRequestedEvent) => void): void;
        once(event: "inspectNodeRequested", listener: (params: Protocol.Overlay.InspectNodeRequestedEvent) => void): void;
        once(event: `inspectNodeRequested.${SessionId}`, listener: (params: Protocol.Overlay.InspectNodeRequestedEvent) => void): void;
        off(event: "inspectNodeRequested", listener: (params: Protocol.Overlay.InspectNodeRequestedEvent) => void): void;
        off(event: `inspectNodeRequested.${SessionId}`, listener: (params: Protocol.Overlay.InspectNodeRequestedEvent) => void): void;
        inspectNodeRequested(sessionId?: SessionId): Promise<Protocol.Overlay.InspectNodeRequestedEvent>;

        /**
         * Fired when the node should be highlighted. This happens after call to `setInspectMode`.
         */
        on(event: "nodeHighlightRequested", listener: (params: Protocol.Overlay.NodeHighlightRequestedEvent) => void): void;
        on(event: `nodeHighlightRequested.${SessionId}`, listener: (params: Protocol.Overlay.NodeHighlightRequestedEvent) => void): void;
        once(event: "nodeHighlightRequested", listener: (params: Protocol.Overlay.NodeHighlightRequestedEvent) => void): void;
        once(event: `nodeHighlightRequested.${SessionId}`, listener: (params: Protocol.Overlay.NodeHighlightRequestedEvent) => void): void;
        off(event: "nodeHighlightRequested", listener: (params: Protocol.Overlay.NodeHighlightRequestedEvent) => void): void;
        off(event: `nodeHighlightRequested.${SessionId}`, listener: (params: Protocol.Overlay.NodeHighlightRequestedEvent) => void): void;
        nodeHighlightRequested(sessionId?: SessionId): Promise<Protocol.Overlay.NodeHighlightRequestedEvent>;

        /**
         * Fired when user asks to capture screenshot of some area on the page.
         */
        on(event: "screenshotRequested", listener: (params: Protocol.Overlay.ScreenshotRequestedEvent) => void): void;
        on(event: `screenshotRequested.${SessionId}`, listener: (params: Protocol.Overlay.ScreenshotRequestedEvent) => void): void;
        once(event: "screenshotRequested", listener: (params: Protocol.Overlay.ScreenshotRequestedEvent) => void): void;
        once(event: `screenshotRequested.${SessionId}`, listener: (params: Protocol.Overlay.ScreenshotRequestedEvent) => void): void;
        off(event: "screenshotRequested", listener: (params: Protocol.Overlay.ScreenshotRequestedEvent) => void): void;
        off(event: `screenshotRequested.${SessionId}`, listener: (params: Protocol.Overlay.ScreenshotRequestedEvent) => void): void;
        screenshotRequested(sessionId?: SessionId): Promise<Protocol.Overlay.ScreenshotRequestedEvent>;

        /**
         * Fired when user cancels the inspect mode.
         */
        on(event: "inspectModeCanceled", listener: () => void): void;
        on(event: `inspectModeCanceled.${SessionId}`, listener: () => void): void;
        once(event: "inspectModeCanceled", listener: () => void): void;
        once(event: `inspectModeCanceled.${SessionId}`, listener: () => void): void;
        off(event: "inspectModeCanceled", listener: () => void): void;
        off(event: `inspectModeCanceled.${SessionId}`, listener: () => void): void;
        inspectModeCanceled(sessionId?: SessionId): Promise<void>;

    }

    export type PageApi = {
        /**
         * Deprecated, please use addScriptToEvaluateOnNewDocument instead.
         */
        addScriptToEvaluateOnLoad(params: Protocol.Page.AddScriptToEvaluateOnLoadRequest, sessionId?: SessionId): Promise<Protocol.Page.AddScriptToEvaluateOnLoadResponse>;

        /**
         * Evaluates given script in every frame upon creation (before loading frame's scripts).
         */
        addScriptToEvaluateOnNewDocument(params: Protocol.Page.AddScriptToEvaluateOnNewDocumentRequest, sessionId?: SessionId): Promise<Protocol.Page.AddScriptToEvaluateOnNewDocumentResponse>;

        /**
         * Brings page to front (activates tab).
         */
        bringToFront(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Capture page screenshot.
         */
        captureScreenshot(params?: Protocol.Page.CaptureScreenshotRequest, sessionId?: SessionId): Promise<Protocol.Page.CaptureScreenshotResponse>;

        /**
         * Returns a snapshot of the page as a string. For MHTML format, the serialization includes
         * iframes, shadow DOM, external resources, and element-inline styles.
         */
        captureSnapshot(params?: Protocol.Page.CaptureSnapshotRequest, sessionId?: SessionId): Promise<Protocol.Page.CaptureSnapshotResponse>;

        /**
         * Clears the overridden device metrics.
         */
        clearDeviceMetricsOverride(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Clears the overridden Device Orientation.
         */
        clearDeviceOrientationOverride(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Clears the overridden Geolocation Position and Error.
         */
        clearGeolocationOverride(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Creates an isolated world for the given frame.
         */
        createIsolatedWorld(params: Protocol.Page.CreateIsolatedWorldRequest, sessionId?: SessionId): Promise<Protocol.Page.CreateIsolatedWorldResponse>;

        /**
         * Deletes browser cookie with given name, domain and path.
         */
        deleteCookie(params: Protocol.Page.DeleteCookieRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Disables page domain notifications.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables page domain notifications.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        getAppManifest(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Page.GetAppManifestResponse>;

        getInstallabilityErrors(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Page.GetInstallabilityErrorsResponse>;

        getManifestIcons(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Page.GetManifestIconsResponse>;

        /**
         * Returns the unique (PWA) app id.
         * Only returns values if the feature flag 'WebAppEnableManifestId' is enabled
         */
        getAppId(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Page.GetAppIdResponse>;

        getAdScriptId(params: Protocol.Page.GetAdScriptIdRequest, sessionId?: SessionId): Promise<Protocol.Page.GetAdScriptIdResponse>;

        /**
         * Returns all browser cookies for the page and all of its subframes. Depending
         * on the backend support, will return detailed cookie information in the
         * `cookies` field.
         */
        getCookies(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Page.GetCookiesResponse>;

        /**
         * Returns present frame tree structure.
         */
        getFrameTree(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Page.GetFrameTreeResponse>;

        /**
         * Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
         */
        getLayoutMetrics(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Page.GetLayoutMetricsResponse>;

        /**
         * Returns navigation history for the current page.
         */
        getNavigationHistory(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Page.GetNavigationHistoryResponse>;

        /**
         * Resets navigation history for the current page.
         */
        resetNavigationHistory(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Returns content of the given resource.
         */
        getResourceContent(params: Protocol.Page.GetResourceContentRequest, sessionId?: SessionId): Promise<Protocol.Page.GetResourceContentResponse>;

        /**
         * Returns present frame / resource tree structure.
         */
        getResourceTree(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Page.GetResourceTreeResponse>;

        /**
         * Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
         */
        handleJavaScriptDialog(params: Protocol.Page.HandleJavaScriptDialogRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Navigates current page to the given URL.
         */
        navigate(params: Protocol.Page.NavigateRequest, sessionId?: SessionId): Promise<Protocol.Page.NavigateResponse>;

        /**
         * Navigates current page to the given history entry.
         */
        navigateToHistoryEntry(params: Protocol.Page.NavigateToHistoryEntryRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Print page as PDF.
         */
        printToPDF(params?: Protocol.Page.PrintToPDFRequest, sessionId?: SessionId): Promise<Protocol.Page.PrintToPDFResponse>;

        /**
         * Reloads given page optionally ignoring the cache.
         */
        reload(params?: Protocol.Page.ReloadRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Deprecated, please use removeScriptToEvaluateOnNewDocument instead.
         */
        removeScriptToEvaluateOnLoad(params: Protocol.Page.RemoveScriptToEvaluateOnLoadRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Removes given script from the list.
         */
        removeScriptToEvaluateOnNewDocument(params: Protocol.Page.RemoveScriptToEvaluateOnNewDocumentRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Acknowledges that a screencast frame has been received by the frontend.
         */
        screencastFrameAck(params: Protocol.Page.ScreencastFrameAckRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Searches for given string in resource content.
         */
        searchInResource(params: Protocol.Page.SearchInResourceRequest, sessionId?: SessionId): Promise<Protocol.Page.SearchInResourceResponse>;

        /**
         * Enable Chrome's experimental ad filter on all sites.
         */
        setAdBlockingEnabled(params: Protocol.Page.SetAdBlockingEnabledRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Enable page Content Security Policy by-passing.
         */
        setBypassCSP(params: Protocol.Page.SetBypassCSPRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Get Permissions Policy state on given frame.
         */
        getPermissionsPolicyState(params: Protocol.Page.GetPermissionsPolicyStateRequest, sessionId?: SessionId): Promise<Protocol.Page.GetPermissionsPolicyStateResponse>;

        /**
         * Get Origin Trials on given frame.
         */
        getOriginTrials(params: Protocol.Page.GetOriginTrialsRequest, sessionId?: SessionId): Promise<Protocol.Page.GetOriginTrialsResponse>;

        /**
         * Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
         * window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
         * query results).
         */
        setDeviceMetricsOverride(params: Protocol.Page.SetDeviceMetricsOverrideRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Overrides the Device Orientation.
         */
        setDeviceOrientationOverride(params: Protocol.Page.SetDeviceOrientationOverrideRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Set generic font families.
         */
        setFontFamilies(params: Protocol.Page.SetFontFamiliesRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Set default font sizes.
         */
        setFontSizes(params: Protocol.Page.SetFontSizesRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets given markup as the document's HTML.
         */
        setDocumentContent(params: Protocol.Page.SetDocumentContentRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Set the behavior when downloading a file.
         */
        setDownloadBehavior(params: Protocol.Page.SetDownloadBehaviorRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
         * unavailable.
         */
        setGeolocationOverride(params?: Protocol.Page.SetGeolocationOverrideRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Controls whether page will emit lifecycle events.
         */
        setLifecycleEventsEnabled(params: Protocol.Page.SetLifecycleEventsEnabledRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Toggles mouse event-based touch event emulation.
         */
        setTouchEmulationEnabled(params: Protocol.Page.SetTouchEmulationEnabledRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Starts sending each frame using the `screencastFrame` event.
         */
        startScreencast(params?: Protocol.Page.StartScreencastRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Force the page stop all navigations and pending resource fetches.
         */
        stopLoading(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Crashes renderer on the IO thread, generates minidumps.
         */
        crash(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Tries to close page, running its beforeunload hooks, if any.
         */
        close(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Tries to update the web lifecycle state of the page.
         * It will transition the page to the given state according to:
         * https://github.com/WICG/web-lifecycle/
         */
        setWebLifecycleState(params: Protocol.Page.SetWebLifecycleStateRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Stops sending each frame in the `screencastFrame`.
         */
        stopScreencast(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Requests backend to produce compilation cache for the specified scripts.
         * `scripts` are appeneded to the list of scripts for which the cache
         * would be produced. The list may be reset during page navigation.
         * When script with a matching URL is encountered, the cache is optionally
         * produced upon backend discretion, based on internal heuristics.
         * See also: `Page.compilationCacheProduced`.
         */
        produceCompilationCache(params: Protocol.Page.ProduceCompilationCacheRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Seeds compilation cache for given url. Compilation cache does not survive
         * cross-process navigation.
         */
        addCompilationCache(params: Protocol.Page.AddCompilationCacheRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Clears seeded compilation cache.
         */
        clearCompilationCache(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Sets the Secure Payment Confirmation transaction mode.
         * https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode
         */
        setSPCTransactionMode(params: Protocol.Page.SetSPCTransactionModeRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Generates a report for testing.
         */
        generateTestReport(params: Protocol.Page.GenerateTestReportRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.
         */
        waitForDebugger(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Intercept file chooser requests and transfer control to protocol clients.
         * When file chooser interception is enabled, native file chooser dialog is not shown.
         * Instead, a protocol event `Page.fileChooserOpened` is emitted.
         */
        setInterceptFileChooserDialog(params: Protocol.Page.SetInterceptFileChooserDialogRequest, sessionId?: SessionId): Promise<void>;

        on(event: "domContentEventFired", listener: (params: Protocol.Page.DomContentEventFiredEvent) => void): void;
        on(event: `domContentEventFired.${SessionId}`, listener: (params: Protocol.Page.DomContentEventFiredEvent) => void): void;
        once(event: "domContentEventFired", listener: (params: Protocol.Page.DomContentEventFiredEvent) => void): void;
        once(event: `domContentEventFired.${SessionId}`, listener: (params: Protocol.Page.DomContentEventFiredEvent) => void): void;
        off(event: "domContentEventFired", listener: (params: Protocol.Page.DomContentEventFiredEvent) => void): void;
        off(event: `domContentEventFired.${SessionId}`, listener: (params: Protocol.Page.DomContentEventFiredEvent) => void): void;
        domContentEventFired(sessionId?: SessionId): Promise<Protocol.Page.DomContentEventFiredEvent>;

        /**
         * Emitted only when `page.interceptFileChooser` is enabled.
         */
        on(event: "fileChooserOpened", listener: (params: Protocol.Page.FileChooserOpenedEvent) => void): void;
        on(event: `fileChooserOpened.${SessionId}`, listener: (params: Protocol.Page.FileChooserOpenedEvent) => void): void;
        once(event: "fileChooserOpened", listener: (params: Protocol.Page.FileChooserOpenedEvent) => void): void;
        once(event: `fileChooserOpened.${SessionId}`, listener: (params: Protocol.Page.FileChooserOpenedEvent) => void): void;
        off(event: "fileChooserOpened", listener: (params: Protocol.Page.FileChooserOpenedEvent) => void): void;
        off(event: `fileChooserOpened.${SessionId}`, listener: (params: Protocol.Page.FileChooserOpenedEvent) => void): void;
        fileChooserOpened(sessionId?: SessionId): Promise<Protocol.Page.FileChooserOpenedEvent>;

        /**
         * Fired when frame has been attached to its parent.
         */
        on(event: "frameAttached", listener: (params: Protocol.Page.FrameAttachedEvent) => void): void;
        on(event: `frameAttached.${SessionId}`, listener: (params: Protocol.Page.FrameAttachedEvent) => void): void;
        once(event: "frameAttached", listener: (params: Protocol.Page.FrameAttachedEvent) => void): void;
        once(event: `frameAttached.${SessionId}`, listener: (params: Protocol.Page.FrameAttachedEvent) => void): void;
        off(event: "frameAttached", listener: (params: Protocol.Page.FrameAttachedEvent) => void): void;
        off(event: `frameAttached.${SessionId}`, listener: (params: Protocol.Page.FrameAttachedEvent) => void): void;
        frameAttached(sessionId?: SessionId): Promise<Protocol.Page.FrameAttachedEvent>;

        /**
         * Fired when frame no longer has a scheduled navigation.
         */
        on(event: "frameClearedScheduledNavigation", listener: (params: Protocol.Page.FrameClearedScheduledNavigationEvent) => void): void;
        on(event: `frameClearedScheduledNavigation.${SessionId}`, listener: (params: Protocol.Page.FrameClearedScheduledNavigationEvent) => void): void;
        once(event: "frameClearedScheduledNavigation", listener: (params: Protocol.Page.FrameClearedScheduledNavigationEvent) => void): void;
        once(event: `frameClearedScheduledNavigation.${SessionId}`, listener: (params: Protocol.Page.FrameClearedScheduledNavigationEvent) => void): void;
        off(event: "frameClearedScheduledNavigation", listener: (params: Protocol.Page.FrameClearedScheduledNavigationEvent) => void): void;
        off(event: `frameClearedScheduledNavigation.${SessionId}`, listener: (params: Protocol.Page.FrameClearedScheduledNavigationEvent) => void): void;
        frameClearedScheduledNavigation(sessionId?: SessionId): Promise<Protocol.Page.FrameClearedScheduledNavigationEvent>;

        /**
         * Fired when frame has been detached from its parent.
         */
        on(event: "frameDetached", listener: (params: Protocol.Page.FrameDetachedEvent) => void): void;
        on(event: `frameDetached.${SessionId}`, listener: (params: Protocol.Page.FrameDetachedEvent) => void): void;
        once(event: "frameDetached", listener: (params: Protocol.Page.FrameDetachedEvent) => void): void;
        once(event: `frameDetached.${SessionId}`, listener: (params: Protocol.Page.FrameDetachedEvent) => void): void;
        off(event: "frameDetached", listener: (params: Protocol.Page.FrameDetachedEvent) => void): void;
        off(event: `frameDetached.${SessionId}`, listener: (params: Protocol.Page.FrameDetachedEvent) => void): void;
        frameDetached(sessionId?: SessionId): Promise<Protocol.Page.FrameDetachedEvent>;

        /**
         * Fired once navigation of the frame has completed. Frame is now associated with the new loader.
         */
        on(event: "frameNavigated", listener: (params: Protocol.Page.FrameNavigatedEvent) => void): void;
        on(event: `frameNavigated.${SessionId}`, listener: (params: Protocol.Page.FrameNavigatedEvent) => void): void;
        once(event: "frameNavigated", listener: (params: Protocol.Page.FrameNavigatedEvent) => void): void;
        once(event: `frameNavigated.${SessionId}`, listener: (params: Protocol.Page.FrameNavigatedEvent) => void): void;
        off(event: "frameNavigated", listener: (params: Protocol.Page.FrameNavigatedEvent) => void): void;
        off(event: `frameNavigated.${SessionId}`, listener: (params: Protocol.Page.FrameNavigatedEvent) => void): void;
        frameNavigated(sessionId?: SessionId): Promise<Protocol.Page.FrameNavigatedEvent>;

        /**
         * Fired when opening document to write to.
         */
        on(event: "documentOpened", listener: (params: Protocol.Page.DocumentOpenedEvent) => void): void;
        on(event: `documentOpened.${SessionId}`, listener: (params: Protocol.Page.DocumentOpenedEvent) => void): void;
        once(event: "documentOpened", listener: (params: Protocol.Page.DocumentOpenedEvent) => void): void;
        once(event: `documentOpened.${SessionId}`, listener: (params: Protocol.Page.DocumentOpenedEvent) => void): void;
        off(event: "documentOpened", listener: (params: Protocol.Page.DocumentOpenedEvent) => void): void;
        off(event: `documentOpened.${SessionId}`, listener: (params: Protocol.Page.DocumentOpenedEvent) => void): void;
        documentOpened(sessionId?: SessionId): Promise<Protocol.Page.DocumentOpenedEvent>;

        on(event: "frameResized", listener: () => void): void;
        on(event: `frameResized.${SessionId}`, listener: () => void): void;
        once(event: "frameResized", listener: () => void): void;
        once(event: `frameResized.${SessionId}`, listener: () => void): void;
        off(event: "frameResized", listener: () => void): void;
        off(event: `frameResized.${SessionId}`, listener: () => void): void;
        frameResized(sessionId?: SessionId): Promise<void>;

        /**
         * Fired when a renderer-initiated navigation is requested.
         * Navigation may still be cancelled after the event is issued.
         */
        on(event: "frameRequestedNavigation", listener: (params: Protocol.Page.FrameRequestedNavigationEvent) => void): void;
        on(event: `frameRequestedNavigation.${SessionId}`, listener: (params: Protocol.Page.FrameRequestedNavigationEvent) => void): void;
        once(event: "frameRequestedNavigation", listener: (params: Protocol.Page.FrameRequestedNavigationEvent) => void): void;
        once(event: `frameRequestedNavigation.${SessionId}`, listener: (params: Protocol.Page.FrameRequestedNavigationEvent) => void): void;
        off(event: "frameRequestedNavigation", listener: (params: Protocol.Page.FrameRequestedNavigationEvent) => void): void;
        off(event: `frameRequestedNavigation.${SessionId}`, listener: (params: Protocol.Page.FrameRequestedNavigationEvent) => void): void;
        frameRequestedNavigation(sessionId?: SessionId): Promise<Protocol.Page.FrameRequestedNavigationEvent>;

        /**
         * Fired when frame schedules a potential navigation.
         */
        on(event: "frameScheduledNavigation", listener: (params: Protocol.Page.FrameScheduledNavigationEvent) => void): void;
        on(event: `frameScheduledNavigation.${SessionId}`, listener: (params: Protocol.Page.FrameScheduledNavigationEvent) => void): void;
        once(event: "frameScheduledNavigation", listener: (params: Protocol.Page.FrameScheduledNavigationEvent) => void): void;
        once(event: `frameScheduledNavigation.${SessionId}`, listener: (params: Protocol.Page.FrameScheduledNavigationEvent) => void): void;
        off(event: "frameScheduledNavigation", listener: (params: Protocol.Page.FrameScheduledNavigationEvent) => void): void;
        off(event: `frameScheduledNavigation.${SessionId}`, listener: (params: Protocol.Page.FrameScheduledNavigationEvent) => void): void;
        frameScheduledNavigation(sessionId?: SessionId): Promise<Protocol.Page.FrameScheduledNavigationEvent>;

        /**
         * Fired when frame has started loading.
         */
        on(event: "frameStartedLoading", listener: (params: Protocol.Page.FrameStartedLoadingEvent) => void): void;
        on(event: `frameStartedLoading.${SessionId}`, listener: (params: Protocol.Page.FrameStartedLoadingEvent) => void): void;
        once(event: "frameStartedLoading", listener: (params: Protocol.Page.FrameStartedLoadingEvent) => void): void;
        once(event: `frameStartedLoading.${SessionId}`, listener: (params: Protocol.Page.FrameStartedLoadingEvent) => void): void;
        off(event: "frameStartedLoading", listener: (params: Protocol.Page.FrameStartedLoadingEvent) => void): void;
        off(event: `frameStartedLoading.${SessionId}`, listener: (params: Protocol.Page.FrameStartedLoadingEvent) => void): void;
        frameStartedLoading(sessionId?: SessionId): Promise<Protocol.Page.FrameStartedLoadingEvent>;

        /**
         * Fired when frame has stopped loading.
         */
        on(event: "frameStoppedLoading", listener: (params: Protocol.Page.FrameStoppedLoadingEvent) => void): void;
        on(event: `frameStoppedLoading.${SessionId}`, listener: (params: Protocol.Page.FrameStoppedLoadingEvent) => void): void;
        once(event: "frameStoppedLoading", listener: (params: Protocol.Page.FrameStoppedLoadingEvent) => void): void;
        once(event: `frameStoppedLoading.${SessionId}`, listener: (params: Protocol.Page.FrameStoppedLoadingEvent) => void): void;
        off(event: "frameStoppedLoading", listener: (params: Protocol.Page.FrameStoppedLoadingEvent) => void): void;
        off(event: `frameStoppedLoading.${SessionId}`, listener: (params: Protocol.Page.FrameStoppedLoadingEvent) => void): void;
        frameStoppedLoading(sessionId?: SessionId): Promise<Protocol.Page.FrameStoppedLoadingEvent>;

        /**
         * Fired when page is about to start a download.
         * Deprecated. Use Browser.downloadWillBegin instead.
         */
        on(event: "downloadWillBegin", listener: (params: Protocol.Page.DownloadWillBeginEvent) => void): void;
        on(event: `downloadWillBegin.${SessionId}`, listener: (params: Protocol.Page.DownloadWillBeginEvent) => void): void;
        once(event: "downloadWillBegin", listener: (params: Protocol.Page.DownloadWillBeginEvent) => void): void;
        once(event: `downloadWillBegin.${SessionId}`, listener: (params: Protocol.Page.DownloadWillBeginEvent) => void): void;
        off(event: "downloadWillBegin", listener: (params: Protocol.Page.DownloadWillBeginEvent) => void): void;
        off(event: `downloadWillBegin.${SessionId}`, listener: (params: Protocol.Page.DownloadWillBeginEvent) => void): void;
        downloadWillBegin(sessionId?: SessionId): Promise<Protocol.Page.DownloadWillBeginEvent>;

        /**
         * Fired when download makes progress. Last call has |done| == true.
         * Deprecated. Use Browser.downloadProgress instead.
         */
        on(event: "downloadProgress", listener: (params: Protocol.Page.DownloadProgressEvent) => void): void;
        on(event: `downloadProgress.${SessionId}`, listener: (params: Protocol.Page.DownloadProgressEvent) => void): void;
        once(event: "downloadProgress", listener: (params: Protocol.Page.DownloadProgressEvent) => void): void;
        once(event: `downloadProgress.${SessionId}`, listener: (params: Protocol.Page.DownloadProgressEvent) => void): void;
        off(event: "downloadProgress", listener: (params: Protocol.Page.DownloadProgressEvent) => void): void;
        off(event: `downloadProgress.${SessionId}`, listener: (params: Protocol.Page.DownloadProgressEvent) => void): void;
        downloadProgress(sessionId?: SessionId): Promise<Protocol.Page.DownloadProgressEvent>;

        /**
         * Fired when interstitial page was hidden
         */
        on(event: "interstitialHidden", listener: () => void): void;
        on(event: `interstitialHidden.${SessionId}`, listener: () => void): void;
        once(event: "interstitialHidden", listener: () => void): void;
        once(event: `interstitialHidden.${SessionId}`, listener: () => void): void;
        off(event: "interstitialHidden", listener: () => void): void;
        off(event: `interstitialHidden.${SessionId}`, listener: () => void): void;
        interstitialHidden(sessionId?: SessionId): Promise<void>;

        /**
         * Fired when interstitial page was shown
         */
        on(event: "interstitialShown", listener: () => void): void;
        on(event: `interstitialShown.${SessionId}`, listener: () => void): void;
        once(event: "interstitialShown", listener: () => void): void;
        once(event: `interstitialShown.${SessionId}`, listener: () => void): void;
        off(event: "interstitialShown", listener: () => void): void;
        off(event: `interstitialShown.${SessionId}`, listener: () => void): void;
        interstitialShown(sessionId?: SessionId): Promise<void>;

        /**
         * Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been
         * closed.
         */
        on(event: "javascriptDialogClosed", listener: (params: Protocol.Page.JavascriptDialogClosedEvent) => void): void;
        on(event: `javascriptDialogClosed.${SessionId}`, listener: (params: Protocol.Page.JavascriptDialogClosedEvent) => void): void;
        once(event: "javascriptDialogClosed", listener: (params: Protocol.Page.JavascriptDialogClosedEvent) => void): void;
        once(event: `javascriptDialogClosed.${SessionId}`, listener: (params: Protocol.Page.JavascriptDialogClosedEvent) => void): void;
        off(event: "javascriptDialogClosed", listener: (params: Protocol.Page.JavascriptDialogClosedEvent) => void): void;
        off(event: `javascriptDialogClosed.${SessionId}`, listener: (params: Protocol.Page.JavascriptDialogClosedEvent) => void): void;
        javascriptDialogClosed(sessionId?: SessionId): Promise<Protocol.Page.JavascriptDialogClosedEvent>;

        /**
         * Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to
         * open.
         */
        on(event: "javascriptDialogOpening", listener: (params: Protocol.Page.JavascriptDialogOpeningEvent) => void): void;
        on(event: `javascriptDialogOpening.${SessionId}`, listener: (params: Protocol.Page.JavascriptDialogOpeningEvent) => void): void;
        once(event: "javascriptDialogOpening", listener: (params: Protocol.Page.JavascriptDialogOpeningEvent) => void): void;
        once(event: `javascriptDialogOpening.${SessionId}`, listener: (params: Protocol.Page.JavascriptDialogOpeningEvent) => void): void;
        off(event: "javascriptDialogOpening", listener: (params: Protocol.Page.JavascriptDialogOpeningEvent) => void): void;
        off(event: `javascriptDialogOpening.${SessionId}`, listener: (params: Protocol.Page.JavascriptDialogOpeningEvent) => void): void;
        javascriptDialogOpening(sessionId?: SessionId): Promise<Protocol.Page.JavascriptDialogOpeningEvent>;

        /**
         * Fired for top level page lifecycle events such as navigation, load, paint, etc.
         */
        on(event: "lifecycleEvent", listener: (params: Protocol.Page.LifecycleEventEvent) => void): void;
        on(event: `lifecycleEvent.${SessionId}`, listener: (params: Protocol.Page.LifecycleEventEvent) => void): void;
        once(event: "lifecycleEvent", listener: (params: Protocol.Page.LifecycleEventEvent) => void): void;
        once(event: `lifecycleEvent.${SessionId}`, listener: (params: Protocol.Page.LifecycleEventEvent) => void): void;
        off(event: "lifecycleEvent", listener: (params: Protocol.Page.LifecycleEventEvent) => void): void;
        off(event: `lifecycleEvent.${SessionId}`, listener: (params: Protocol.Page.LifecycleEventEvent) => void): void;
        lifecycleEvent(sessionId?: SessionId): Promise<Protocol.Page.LifecycleEventEvent>;

        /**
         * Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do
         * not assume any ordering with the Page.frameNavigated event. This event is fired only for
         * main-frame history navigation where the document changes (non-same-document navigations),
         * when bfcache navigation fails.
         */
        on(event: "backForwardCacheNotUsed", listener: (params: Protocol.Page.BackForwardCacheNotUsedEvent) => void): void;
        on(event: `backForwardCacheNotUsed.${SessionId}`, listener: (params: Protocol.Page.BackForwardCacheNotUsedEvent) => void): void;
        once(event: "backForwardCacheNotUsed", listener: (params: Protocol.Page.BackForwardCacheNotUsedEvent) => void): void;
        once(event: `backForwardCacheNotUsed.${SessionId}`, listener: (params: Protocol.Page.BackForwardCacheNotUsedEvent) => void): void;
        off(event: "backForwardCacheNotUsed", listener: (params: Protocol.Page.BackForwardCacheNotUsedEvent) => void): void;
        off(event: `backForwardCacheNotUsed.${SessionId}`, listener: (params: Protocol.Page.BackForwardCacheNotUsedEvent) => void): void;
        backForwardCacheNotUsed(sessionId?: SessionId): Promise<Protocol.Page.BackForwardCacheNotUsedEvent>;

        /**
         * Fired when a prerender attempt is completed.
         */
        on(event: "prerenderAttemptCompleted", listener: (params: Protocol.Page.PrerenderAttemptCompletedEvent) => void): void;
        on(event: `prerenderAttemptCompleted.${SessionId}`, listener: (params: Protocol.Page.PrerenderAttemptCompletedEvent) => void): void;
        once(event: "prerenderAttemptCompleted", listener: (params: Protocol.Page.PrerenderAttemptCompletedEvent) => void): void;
        once(event: `prerenderAttemptCompleted.${SessionId}`, listener: (params: Protocol.Page.PrerenderAttemptCompletedEvent) => void): void;
        off(event: "prerenderAttemptCompleted", listener: (params: Protocol.Page.PrerenderAttemptCompletedEvent) => void): void;
        off(event: `prerenderAttemptCompleted.${SessionId}`, listener: (params: Protocol.Page.PrerenderAttemptCompletedEvent) => void): void;
        prerenderAttemptCompleted(sessionId?: SessionId): Promise<Protocol.Page.PrerenderAttemptCompletedEvent>;

        on(event: "loadEventFired", listener: (params: Protocol.Page.LoadEventFiredEvent) => void): void;
        on(event: `loadEventFired.${SessionId}`, listener: (params: Protocol.Page.LoadEventFiredEvent) => void): void;
        once(event: "loadEventFired", listener: (params: Protocol.Page.LoadEventFiredEvent) => void): void;
        once(event: `loadEventFired.${SessionId}`, listener: (params: Protocol.Page.LoadEventFiredEvent) => void): void;
        off(event: "loadEventFired", listener: (params: Protocol.Page.LoadEventFiredEvent) => void): void;
        off(event: `loadEventFired.${SessionId}`, listener: (params: Protocol.Page.LoadEventFiredEvent) => void): void;
        loadEventFired(sessionId?: SessionId): Promise<Protocol.Page.LoadEventFiredEvent>;

        /**
         * Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.
         */
        on(event: "navigatedWithinDocument", listener: (params: Protocol.Page.NavigatedWithinDocumentEvent) => void): void;
        on(event: `navigatedWithinDocument.${SessionId}`, listener: (params: Protocol.Page.NavigatedWithinDocumentEvent) => void): void;
        once(event: "navigatedWithinDocument", listener: (params: Protocol.Page.NavigatedWithinDocumentEvent) => void): void;
        once(event: `navigatedWithinDocument.${SessionId}`, listener: (params: Protocol.Page.NavigatedWithinDocumentEvent) => void): void;
        off(event: "navigatedWithinDocument", listener: (params: Protocol.Page.NavigatedWithinDocumentEvent) => void): void;
        off(event: `navigatedWithinDocument.${SessionId}`, listener: (params: Protocol.Page.NavigatedWithinDocumentEvent) => void): void;
        navigatedWithinDocument(sessionId?: SessionId): Promise<Protocol.Page.NavigatedWithinDocumentEvent>;

        /**
         * Compressed image data requested by the `startScreencast`.
         */
        on(event: "screencastFrame", listener: (params: Protocol.Page.ScreencastFrameEvent) => void): void;
        on(event: `screencastFrame.${SessionId}`, listener: (params: Protocol.Page.ScreencastFrameEvent) => void): void;
        once(event: "screencastFrame", listener: (params: Protocol.Page.ScreencastFrameEvent) => void): void;
        once(event: `screencastFrame.${SessionId}`, listener: (params: Protocol.Page.ScreencastFrameEvent) => void): void;
        off(event: "screencastFrame", listener: (params: Protocol.Page.ScreencastFrameEvent) => void): void;
        off(event: `screencastFrame.${SessionId}`, listener: (params: Protocol.Page.ScreencastFrameEvent) => void): void;
        screencastFrame(sessionId?: SessionId): Promise<Protocol.Page.ScreencastFrameEvent>;

        /**
         * Fired when the page with currently enabled screencast was shown or hidden `.
         */
        on(event: "screencastVisibilityChanged", listener: (params: Protocol.Page.ScreencastVisibilityChangedEvent) => void): void;
        on(event: `screencastVisibilityChanged.${SessionId}`, listener: (params: Protocol.Page.ScreencastVisibilityChangedEvent) => void): void;
        once(event: "screencastVisibilityChanged", listener: (params: Protocol.Page.ScreencastVisibilityChangedEvent) => void): void;
        once(event: `screencastVisibilityChanged.${SessionId}`, listener: (params: Protocol.Page.ScreencastVisibilityChangedEvent) => void): void;
        off(event: "screencastVisibilityChanged", listener: (params: Protocol.Page.ScreencastVisibilityChangedEvent) => void): void;
        off(event: `screencastVisibilityChanged.${SessionId}`, listener: (params: Protocol.Page.ScreencastVisibilityChangedEvent) => void): void;
        screencastVisibilityChanged(sessionId?: SessionId): Promise<Protocol.Page.ScreencastVisibilityChangedEvent>;

        /**
         * Fired when a new window is going to be opened, via window.open(), link click, form submission,
         * etc.
         */
        on(event: "windowOpen", listener: (params: Protocol.Page.WindowOpenEvent) => void): void;
        on(event: `windowOpen.${SessionId}`, listener: (params: Protocol.Page.WindowOpenEvent) => void): void;
        once(event: "windowOpen", listener: (params: Protocol.Page.WindowOpenEvent) => void): void;
        once(event: `windowOpen.${SessionId}`, listener: (params: Protocol.Page.WindowOpenEvent) => void): void;
        off(event: "windowOpen", listener: (params: Protocol.Page.WindowOpenEvent) => void): void;
        off(event: `windowOpen.${SessionId}`, listener: (params: Protocol.Page.WindowOpenEvent) => void): void;
        windowOpen(sessionId?: SessionId): Promise<Protocol.Page.WindowOpenEvent>;

        /**
         * Issued for every compilation cache generated. Is only available
         * if Page.setGenerateCompilationCache is enabled.
         */
        on(event: "compilationCacheProduced", listener: (params: Protocol.Page.CompilationCacheProducedEvent) => void): void;
        on(event: `compilationCacheProduced.${SessionId}`, listener: (params: Protocol.Page.CompilationCacheProducedEvent) => void): void;
        once(event: "compilationCacheProduced", listener: (params: Protocol.Page.CompilationCacheProducedEvent) => void): void;
        once(event: `compilationCacheProduced.${SessionId}`, listener: (params: Protocol.Page.CompilationCacheProducedEvent) => void): void;
        off(event: "compilationCacheProduced", listener: (params: Protocol.Page.CompilationCacheProducedEvent) => void): void;
        off(event: `compilationCacheProduced.${SessionId}`, listener: (params: Protocol.Page.CompilationCacheProducedEvent) => void): void;
        compilationCacheProduced(sessionId?: SessionId): Promise<Protocol.Page.CompilationCacheProducedEvent>;

    }

    export type PerformanceApi = {
        /**
         * Disable collecting and reporting metrics.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enable collecting and reporting metrics.
         */
        enable(params?: Protocol.Performance.EnableRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets time domain to use for collecting and reporting duration metrics.
         * Note that this must be called before enabling metrics collection. Calling
         * this method while metrics collection is enabled returns an error.
         */
        setTimeDomain(params: Protocol.Performance.SetTimeDomainRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Retrieve current values of run-time metrics.
         */
        getMetrics(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Performance.GetMetricsResponse>;

        /**
         * Current values of the metrics.
         */
        on(event: "metrics", listener: (params: Protocol.Performance.MetricsEvent) => void): void;
        on(event: `metrics.${SessionId}`, listener: (params: Protocol.Performance.MetricsEvent) => void): void;
        once(event: "metrics", listener: (params: Protocol.Performance.MetricsEvent) => void): void;
        once(event: `metrics.${SessionId}`, listener: (params: Protocol.Performance.MetricsEvent) => void): void;
        off(event: "metrics", listener: (params: Protocol.Performance.MetricsEvent) => void): void;
        off(event: `metrics.${SessionId}`, listener: (params: Protocol.Performance.MetricsEvent) => void): void;
        metrics(sessionId?: SessionId): Promise<Protocol.Performance.MetricsEvent>;

    }

    export type PerformanceTimelineApi = {
        /**
         * Previously buffered events would be reported before method returns.
         * See also: timelineEventAdded
         */
        enable(params: Protocol.PerformanceTimeline.EnableRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sent when a performance timeline event is added. See reportPerformanceTimeline method.
         */
        on(event: "timelineEventAdded", listener: (params: Protocol.PerformanceTimeline.TimelineEventAddedEvent) => void): void;
        on(event: `timelineEventAdded.${SessionId}`, listener: (params: Protocol.PerformanceTimeline.TimelineEventAddedEvent) => void): void;
        once(event: "timelineEventAdded", listener: (params: Protocol.PerformanceTimeline.TimelineEventAddedEvent) => void): void;
        once(event: `timelineEventAdded.${SessionId}`, listener: (params: Protocol.PerformanceTimeline.TimelineEventAddedEvent) => void): void;
        off(event: "timelineEventAdded", listener: (params: Protocol.PerformanceTimeline.TimelineEventAddedEvent) => void): void;
        off(event: `timelineEventAdded.${SessionId}`, listener: (params: Protocol.PerformanceTimeline.TimelineEventAddedEvent) => void): void;
        timelineEventAdded(sessionId?: SessionId): Promise<Protocol.PerformanceTimeline.TimelineEventAddedEvent>;

    }

    export type SecurityApi = {
        /**
         * Disables tracking security state changes.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables tracking security state changes.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enable/disable whether all certificate errors should be ignored.
         */
        setIgnoreCertificateErrors(params: Protocol.Security.SetIgnoreCertificateErrorsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Handles a certificate error that fired a certificateError event.
         */
        handleCertificateError(params: Protocol.Security.HandleCertificateErrorRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Enable/disable overriding certificate errors. If enabled, all certificate error events need to
         * be handled by the DevTools client and should be answered with `handleCertificateError` commands.
         */
        setOverrideCertificateErrors(params: Protocol.Security.SetOverrideCertificateErrorsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * There is a certificate error. If overriding certificate errors is enabled, then it should be
         * handled with the `handleCertificateError` command. Note: this event does not fire if the
         * certificate error has been allowed internally. Only one client per target should override
         * certificate errors at the same time.
         */
        on(event: "certificateError", listener: (params: Protocol.Security.CertificateErrorEvent) => void): void;
        on(event: `certificateError.${SessionId}`, listener: (params: Protocol.Security.CertificateErrorEvent) => void): void;
        once(event: "certificateError", listener: (params: Protocol.Security.CertificateErrorEvent) => void): void;
        once(event: `certificateError.${SessionId}`, listener: (params: Protocol.Security.CertificateErrorEvent) => void): void;
        off(event: "certificateError", listener: (params: Protocol.Security.CertificateErrorEvent) => void): void;
        off(event: `certificateError.${SessionId}`, listener: (params: Protocol.Security.CertificateErrorEvent) => void): void;
        certificateError(sessionId?: SessionId): Promise<Protocol.Security.CertificateErrorEvent>;

        /**
         * The security state of the page changed.
         */
        on(event: "visibleSecurityStateChanged", listener: (params: Protocol.Security.VisibleSecurityStateChangedEvent) => void): void;
        on(event: `visibleSecurityStateChanged.${SessionId}`, listener: (params: Protocol.Security.VisibleSecurityStateChangedEvent) => void): void;
        once(event: "visibleSecurityStateChanged", listener: (params: Protocol.Security.VisibleSecurityStateChangedEvent) => void): void;
        once(event: `visibleSecurityStateChanged.${SessionId}`, listener: (params: Protocol.Security.VisibleSecurityStateChangedEvent) => void): void;
        off(event: "visibleSecurityStateChanged", listener: (params: Protocol.Security.VisibleSecurityStateChangedEvent) => void): void;
        off(event: `visibleSecurityStateChanged.${SessionId}`, listener: (params: Protocol.Security.VisibleSecurityStateChangedEvent) => void): void;
        visibleSecurityStateChanged(sessionId?: SessionId): Promise<Protocol.Security.VisibleSecurityStateChangedEvent>;

        /**
         * The security state of the page changed. No longer being sent.
         */
        on(event: "securityStateChanged", listener: (params: Protocol.Security.SecurityStateChangedEvent) => void): void;
        on(event: `securityStateChanged.${SessionId}`, listener: (params: Protocol.Security.SecurityStateChangedEvent) => void): void;
        once(event: "securityStateChanged", listener: (params: Protocol.Security.SecurityStateChangedEvent) => void): void;
        once(event: `securityStateChanged.${SessionId}`, listener: (params: Protocol.Security.SecurityStateChangedEvent) => void): void;
        off(event: "securityStateChanged", listener: (params: Protocol.Security.SecurityStateChangedEvent) => void): void;
        off(event: `securityStateChanged.${SessionId}`, listener: (params: Protocol.Security.SecurityStateChangedEvent) => void): void;
        securityStateChanged(sessionId?: SessionId): Promise<Protocol.Security.SecurityStateChangedEvent>;

    }

    export type ServiceWorkerApi = {
        deliverPushMessage(params: Protocol.ServiceWorker.DeliverPushMessageRequest, sessionId?: SessionId): Promise<void>;

        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        dispatchSyncEvent(params: Protocol.ServiceWorker.DispatchSyncEventRequest, sessionId?: SessionId): Promise<void>;

        dispatchPeriodicSyncEvent(params: Protocol.ServiceWorker.DispatchPeriodicSyncEventRequest, sessionId?: SessionId): Promise<void>;

        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        inspectWorker(params: Protocol.ServiceWorker.InspectWorkerRequest, sessionId?: SessionId): Promise<void>;

        setForceUpdateOnPageLoad(params: Protocol.ServiceWorker.SetForceUpdateOnPageLoadRequest, sessionId?: SessionId): Promise<void>;

        skipWaiting(params: Protocol.ServiceWorker.SkipWaitingRequest, sessionId?: SessionId): Promise<void>;

        startWorker(params: Protocol.ServiceWorker.StartWorkerRequest, sessionId?: SessionId): Promise<void>;

        stopAllWorkers(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        stopWorker(params: Protocol.ServiceWorker.StopWorkerRequest, sessionId?: SessionId): Promise<void>;

        unregister(params: Protocol.ServiceWorker.UnregisterRequest, sessionId?: SessionId): Promise<void>;

        updateRegistration(params: Protocol.ServiceWorker.UpdateRegistrationRequest, sessionId?: SessionId): Promise<void>;

        on(event: "workerErrorReported", listener: (params: Protocol.ServiceWorker.WorkerErrorReportedEvent) => void): void;
        on(event: `workerErrorReported.${SessionId}`, listener: (params: Protocol.ServiceWorker.WorkerErrorReportedEvent) => void): void;
        once(event: "workerErrorReported", listener: (params: Protocol.ServiceWorker.WorkerErrorReportedEvent) => void): void;
        once(event: `workerErrorReported.${SessionId}`, listener: (params: Protocol.ServiceWorker.WorkerErrorReportedEvent) => void): void;
        off(event: "workerErrorReported", listener: (params: Protocol.ServiceWorker.WorkerErrorReportedEvent) => void): void;
        off(event: `workerErrorReported.${SessionId}`, listener: (params: Protocol.ServiceWorker.WorkerErrorReportedEvent) => void): void;
        workerErrorReported(sessionId?: SessionId): Promise<Protocol.ServiceWorker.WorkerErrorReportedEvent>;

        on(event: "workerRegistrationUpdated", listener: (params: Protocol.ServiceWorker.WorkerRegistrationUpdatedEvent) => void): void;
        on(event: `workerRegistrationUpdated.${SessionId}`, listener: (params: Protocol.ServiceWorker.WorkerRegistrationUpdatedEvent) => void): void;
        once(event: "workerRegistrationUpdated", listener: (params: Protocol.ServiceWorker.WorkerRegistrationUpdatedEvent) => void): void;
        once(event: `workerRegistrationUpdated.${SessionId}`, listener: (params: Protocol.ServiceWorker.WorkerRegistrationUpdatedEvent) => void): void;
        off(event: "workerRegistrationUpdated", listener: (params: Protocol.ServiceWorker.WorkerRegistrationUpdatedEvent) => void): void;
        off(event: `workerRegistrationUpdated.${SessionId}`, listener: (params: Protocol.ServiceWorker.WorkerRegistrationUpdatedEvent) => void): void;
        workerRegistrationUpdated(sessionId?: SessionId): Promise<Protocol.ServiceWorker.WorkerRegistrationUpdatedEvent>;

        on(event: "workerVersionUpdated", listener: (params: Protocol.ServiceWorker.WorkerVersionUpdatedEvent) => void): void;
        on(event: `workerVersionUpdated.${SessionId}`, listener: (params: Protocol.ServiceWorker.WorkerVersionUpdatedEvent) => void): void;
        once(event: "workerVersionUpdated", listener: (params: Protocol.ServiceWorker.WorkerVersionUpdatedEvent) => void): void;
        once(event: `workerVersionUpdated.${SessionId}`, listener: (params: Protocol.ServiceWorker.WorkerVersionUpdatedEvent) => void): void;
        off(event: "workerVersionUpdated", listener: (params: Protocol.ServiceWorker.WorkerVersionUpdatedEvent) => void): void;
        off(event: `workerVersionUpdated.${SessionId}`, listener: (params: Protocol.ServiceWorker.WorkerVersionUpdatedEvent) => void): void;
        workerVersionUpdated(sessionId?: SessionId): Promise<Protocol.ServiceWorker.WorkerVersionUpdatedEvent>;

    }

    export type StorageApi = {
        /**
         * Returns a storage key given a frame id.
         */
        getStorageKeyForFrame(params: Protocol.Storage.GetStorageKeyForFrameRequest, sessionId?: SessionId): Promise<Protocol.Storage.GetStorageKeyForFrameResponse>;

        /**
         * Clears storage for origin.
         */
        clearDataForOrigin(params: Protocol.Storage.ClearDataForOriginRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Clears storage for storage key.
         */
        clearDataForStorageKey(params: Protocol.Storage.ClearDataForStorageKeyRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Returns all browser cookies.
         */
        getCookies(params?: Protocol.Storage.GetCookiesRequest, sessionId?: SessionId): Promise<Protocol.Storage.GetCookiesResponse>;

        /**
         * Sets given cookies.
         */
        setCookies(params: Protocol.Storage.SetCookiesRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Clears cookies.
         */
        clearCookies(params?: Protocol.Storage.ClearCookiesRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Returns usage and quota in bytes.
         */
        getUsageAndQuota(params: Protocol.Storage.GetUsageAndQuotaRequest, sessionId?: SessionId): Promise<Protocol.Storage.GetUsageAndQuotaResponse>;

        /**
         * Override quota for the specified origin
         */
        overrideQuotaForOrigin(params: Protocol.Storage.OverrideQuotaForOriginRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Registers origin to be notified when an update occurs to its cache storage list.
         */
        trackCacheStorageForOrigin(params: Protocol.Storage.TrackCacheStorageForOriginRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Registers storage key to be notified when an update occurs to its cache storage list.
         */
        trackCacheStorageForStorageKey(params: Protocol.Storage.TrackCacheStorageForStorageKeyRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Registers origin to be notified when an update occurs to its IndexedDB.
         */
        trackIndexedDBForOrigin(params: Protocol.Storage.TrackIndexedDBForOriginRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Registers storage key to be notified when an update occurs to its IndexedDB.
         */
        trackIndexedDBForStorageKey(params: Protocol.Storage.TrackIndexedDBForStorageKeyRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Unregisters origin from receiving notifications for cache storage.
         */
        untrackCacheStorageForOrigin(params: Protocol.Storage.UntrackCacheStorageForOriginRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Unregisters storage key from receiving notifications for cache storage.
         */
        untrackCacheStorageForStorageKey(params: Protocol.Storage.UntrackCacheStorageForStorageKeyRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Unregisters origin from receiving notifications for IndexedDB.
         */
        untrackIndexedDBForOrigin(params: Protocol.Storage.UntrackIndexedDBForOriginRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Unregisters storage key from receiving notifications for IndexedDB.
         */
        untrackIndexedDBForStorageKey(params: Protocol.Storage.UntrackIndexedDBForStorageKeyRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Returns the number of stored Trust Tokens per issuer for the
         * current browsing context.
         */
        getTrustTokens(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Storage.GetTrustTokensResponse>;

        /**
         * Removes all Trust Tokens issued by the provided issuerOrigin.
         * Leaves other stored data, including the issuer's Redemption Records, intact.
         */
        clearTrustTokens(params: Protocol.Storage.ClearTrustTokensRequest, sessionId?: SessionId): Promise<Protocol.Storage.ClearTrustTokensResponse>;

        /**
         * Gets details for a named interest group.
         */
        getInterestGroupDetails(params: Protocol.Storage.GetInterestGroupDetailsRequest, sessionId?: SessionId): Promise<Protocol.Storage.GetInterestGroupDetailsResponse>;

        /**
         * Enables/Disables issuing of interestGroupAccessed events.
         */
        setInterestGroupTracking(params: Protocol.Storage.SetInterestGroupTrackingRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Gets metadata for an origin's shared storage.
         */
        getSharedStorageMetadata(params: Protocol.Storage.GetSharedStorageMetadataRequest, sessionId?: SessionId): Promise<Protocol.Storage.GetSharedStorageMetadataResponse>;

        /**
         * Gets the entries in an given origin's shared storage.
         */
        getSharedStorageEntries(params: Protocol.Storage.GetSharedStorageEntriesRequest, sessionId?: SessionId): Promise<Protocol.Storage.GetSharedStorageEntriesResponse>;

        /**
         * Sets entry with `key` and `value` for a given origin's shared storage.
         */
        setSharedStorageEntry(params: Protocol.Storage.SetSharedStorageEntryRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Deletes entry for `key` (if it exists) for a given origin's shared storage.
         */
        deleteSharedStorageEntry(params: Protocol.Storage.DeleteSharedStorageEntryRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Clears all entries for a given origin's shared storage.
         */
        clearSharedStorageEntries(params: Protocol.Storage.ClearSharedStorageEntriesRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Resets the budget for `ownerOrigin` by clearing all budget withdrawals.
         */
        resetSharedStorageBudget(params: Protocol.Storage.ResetSharedStorageBudgetRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Enables/disables issuing of sharedStorageAccessed events.
         */
        setSharedStorageTracking(params: Protocol.Storage.SetSharedStorageTrackingRequest, sessionId?: SessionId): Promise<void>;

        /**
         * A cache's contents have been modified.
         */
        on(event: "cacheStorageContentUpdated", listener: (params: Protocol.Storage.CacheStorageContentUpdatedEvent) => void): void;
        on(event: `cacheStorageContentUpdated.${SessionId}`, listener: (params: Protocol.Storage.CacheStorageContentUpdatedEvent) => void): void;
        once(event: "cacheStorageContentUpdated", listener: (params: Protocol.Storage.CacheStorageContentUpdatedEvent) => void): void;
        once(event: `cacheStorageContentUpdated.${SessionId}`, listener: (params: Protocol.Storage.CacheStorageContentUpdatedEvent) => void): void;
        off(event: "cacheStorageContentUpdated", listener: (params: Protocol.Storage.CacheStorageContentUpdatedEvent) => void): void;
        off(event: `cacheStorageContentUpdated.${SessionId}`, listener: (params: Protocol.Storage.CacheStorageContentUpdatedEvent) => void): void;
        cacheStorageContentUpdated(sessionId?: SessionId): Promise<Protocol.Storage.CacheStorageContentUpdatedEvent>;

        /**
         * A cache has been added/deleted.
         */
        on(event: "cacheStorageListUpdated", listener: (params: Protocol.Storage.CacheStorageListUpdatedEvent) => void): void;
        on(event: `cacheStorageListUpdated.${SessionId}`, listener: (params: Protocol.Storage.CacheStorageListUpdatedEvent) => void): void;
        once(event: "cacheStorageListUpdated", listener: (params: Protocol.Storage.CacheStorageListUpdatedEvent) => void): void;
        once(event: `cacheStorageListUpdated.${SessionId}`, listener: (params: Protocol.Storage.CacheStorageListUpdatedEvent) => void): void;
        off(event: "cacheStorageListUpdated", listener: (params: Protocol.Storage.CacheStorageListUpdatedEvent) => void): void;
        off(event: `cacheStorageListUpdated.${SessionId}`, listener: (params: Protocol.Storage.CacheStorageListUpdatedEvent) => void): void;
        cacheStorageListUpdated(sessionId?: SessionId): Promise<Protocol.Storage.CacheStorageListUpdatedEvent>;

        /**
         * The origin's IndexedDB object store has been modified.
         */
        on(event: "indexedDBContentUpdated", listener: (params: Protocol.Storage.IndexedDBContentUpdatedEvent) => void): void;
        on(event: `indexedDBContentUpdated.${SessionId}`, listener: (params: Protocol.Storage.IndexedDBContentUpdatedEvent) => void): void;
        once(event: "indexedDBContentUpdated", listener: (params: Protocol.Storage.IndexedDBContentUpdatedEvent) => void): void;
        once(event: `indexedDBContentUpdated.${SessionId}`, listener: (params: Protocol.Storage.IndexedDBContentUpdatedEvent) => void): void;
        off(event: "indexedDBContentUpdated", listener: (params: Protocol.Storage.IndexedDBContentUpdatedEvent) => void): void;
        off(event: `indexedDBContentUpdated.${SessionId}`, listener: (params: Protocol.Storage.IndexedDBContentUpdatedEvent) => void): void;
        indexedDBContentUpdated(sessionId?: SessionId): Promise<Protocol.Storage.IndexedDBContentUpdatedEvent>;

        /**
         * The origin's IndexedDB database list has been modified.
         */
        on(event: "indexedDBListUpdated", listener: (params: Protocol.Storage.IndexedDBListUpdatedEvent) => void): void;
        on(event: `indexedDBListUpdated.${SessionId}`, listener: (params: Protocol.Storage.IndexedDBListUpdatedEvent) => void): void;
        once(event: "indexedDBListUpdated", listener: (params: Protocol.Storage.IndexedDBListUpdatedEvent) => void): void;
        once(event: `indexedDBListUpdated.${SessionId}`, listener: (params: Protocol.Storage.IndexedDBListUpdatedEvent) => void): void;
        off(event: "indexedDBListUpdated", listener: (params: Protocol.Storage.IndexedDBListUpdatedEvent) => void): void;
        off(event: `indexedDBListUpdated.${SessionId}`, listener: (params: Protocol.Storage.IndexedDBListUpdatedEvent) => void): void;
        indexedDBListUpdated(sessionId?: SessionId): Promise<Protocol.Storage.IndexedDBListUpdatedEvent>;

        /**
         * One of the interest groups was accessed by the associated page.
         */
        on(event: "interestGroupAccessed", listener: (params: Protocol.Storage.InterestGroupAccessedEvent) => void): void;
        on(event: `interestGroupAccessed.${SessionId}`, listener: (params: Protocol.Storage.InterestGroupAccessedEvent) => void): void;
        once(event: "interestGroupAccessed", listener: (params: Protocol.Storage.InterestGroupAccessedEvent) => void): void;
        once(event: `interestGroupAccessed.${SessionId}`, listener: (params: Protocol.Storage.InterestGroupAccessedEvent) => void): void;
        off(event: "interestGroupAccessed", listener: (params: Protocol.Storage.InterestGroupAccessedEvent) => void): void;
        off(event: `interestGroupAccessed.${SessionId}`, listener: (params: Protocol.Storage.InterestGroupAccessedEvent) => void): void;
        interestGroupAccessed(sessionId?: SessionId): Promise<Protocol.Storage.InterestGroupAccessedEvent>;

        /**
         * Shared storage was accessed by the associated page.
         * The following parameters are included in all events.
         */
        on(event: "sharedStorageAccessed", listener: (params: Protocol.Storage.SharedStorageAccessedEvent) => void): void;
        on(event: `sharedStorageAccessed.${SessionId}`, listener: (params: Protocol.Storage.SharedStorageAccessedEvent) => void): void;
        once(event: "sharedStorageAccessed", listener: (params: Protocol.Storage.SharedStorageAccessedEvent) => void): void;
        once(event: `sharedStorageAccessed.${SessionId}`, listener: (params: Protocol.Storage.SharedStorageAccessedEvent) => void): void;
        off(event: "sharedStorageAccessed", listener: (params: Protocol.Storage.SharedStorageAccessedEvent) => void): void;
        off(event: `sharedStorageAccessed.${SessionId}`, listener: (params: Protocol.Storage.SharedStorageAccessedEvent) => void): void;
        sharedStorageAccessed(sessionId?: SessionId): Promise<Protocol.Storage.SharedStorageAccessedEvent>;

    }

    export type SystemInfoApi = {
        /**
         * Returns information about the system.
         */
        getInfo(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.SystemInfo.GetInfoResponse>;

        /**
         * Returns information about the feature state.
         */
        getFeatureState(params: Protocol.SystemInfo.GetFeatureStateRequest, sessionId?: SessionId): Promise<Protocol.SystemInfo.GetFeatureStateResponse>;

        /**
         * Returns information about all running processes.
         */
        getProcessInfo(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.SystemInfo.GetProcessInfoResponse>;

    }

    export type TargetApi = {
        /**
         * Activates (focuses) the target.
         */
        activateTarget(params: Protocol.Target.ActivateTargetRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Attaches to the target with given id.
         */
        attachToTarget(params: Protocol.Target.AttachToTargetRequest, sessionId?: SessionId): Promise<Protocol.Target.AttachToTargetResponse>;

        /**
         * Attaches to the browser target, only uses flat sessionId mode.
         */
        attachToBrowserTarget(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Target.AttachToBrowserTargetResponse>;

        /**
         * Closes the target. If the target is a page that gets closed too.
         */
        closeTarget(params: Protocol.Target.CloseTargetRequest, sessionId?: SessionId): Promise<Protocol.Target.CloseTargetResponse>;

        /**
         * Inject object to the target's main frame that provides a communication
         * channel with browser target.
         * 
         * Injected object will be available as `window[bindingName]`.
         * 
         * The object has the follwing API:
         * - `binding.send(json)` - a method to send messages over the remote debugging protocol
         * - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
         */
        exposeDevToolsProtocol(params: Protocol.Target.ExposeDevToolsProtocolRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
         * one.
         */
        createBrowserContext(params?: Protocol.Target.CreateBrowserContextRequest, sessionId?: SessionId): Promise<Protocol.Target.CreateBrowserContextResponse>;

        /**
         * Returns all browser contexts created with `Target.createBrowserContext` method.
         */
        getBrowserContexts(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Target.GetBrowserContextsResponse>;

        /**
         * Creates a new page.
         */
        createTarget(params: Protocol.Target.CreateTargetRequest, sessionId?: SessionId): Promise<Protocol.Target.CreateTargetResponse>;

        /**
         * Detaches session with given id.
         */
        detachFromTarget(params?: Protocol.Target.DetachFromTargetRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Deletes a BrowserContext. All the belonging pages will be closed without calling their
         * beforeunload hooks.
         */
        disposeBrowserContext(params: Protocol.Target.DisposeBrowserContextRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Returns information about a target.
         */
        getTargetInfo(params?: Protocol.Target.GetTargetInfoRequest, sessionId?: SessionId): Promise<Protocol.Target.GetTargetInfoResponse>;

        /**
         * Retrieves a list of available targets.
         */
        getTargets(params?: Protocol.Target.GetTargetsRequest, sessionId?: SessionId): Promise<Protocol.Target.GetTargetsResponse>;

        /**
         * Sends protocol message over session with given id.
         * Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
         * and crbug.com/991325.
         */
        sendMessageToTarget(params: Protocol.Target.SendMessageToTargetRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Controls whether to automatically attach to new targets which are considered to be related to
         * this one. When turned on, attaches to all existing related targets as well. When turned off,
         * automatically detaches from all currently attached targets.
         * This also clears all targets added by `autoAttachRelated` from the list of targets to watch
         * for creation of related targets.
         */
        setAutoAttach(params: Protocol.Target.SetAutoAttachRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Adds the specified target to the list of targets that will be monitored for any related target
         * creation (such as child frames, child workers and new versions of service worker) and reported
         * through `attachedToTarget`. The specified target is also auto-attached.
         * This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent
         * `setAutoAttach`. Only available at the Browser target.
         */
        autoAttachRelated(params: Protocol.Target.AutoAttachRelatedRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Controls whether to discover available targets and notify via
         * `targetCreated/targetInfoChanged/targetDestroyed` events.
         */
        setDiscoverTargets(params: Protocol.Target.SetDiscoverTargetsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
         * `true`.
         */
        setRemoteLocations(params: Protocol.Target.SetRemoteLocationsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Issued when attached to target because of auto-attach or `attachToTarget` command.
         */
        on(event: "attachedToTarget", listener: (params: Protocol.Target.AttachedToTargetEvent) => void): void;
        on(event: `attachedToTarget.${SessionId}`, listener: (params: Protocol.Target.AttachedToTargetEvent) => void): void;
        once(event: "attachedToTarget", listener: (params: Protocol.Target.AttachedToTargetEvent) => void): void;
        once(event: `attachedToTarget.${SessionId}`, listener: (params: Protocol.Target.AttachedToTargetEvent) => void): void;
        off(event: "attachedToTarget", listener: (params: Protocol.Target.AttachedToTargetEvent) => void): void;
        off(event: `attachedToTarget.${SessionId}`, listener: (params: Protocol.Target.AttachedToTargetEvent) => void): void;
        attachedToTarget(sessionId?: SessionId): Promise<Protocol.Target.AttachedToTargetEvent>;

        /**
         * Issued when detached from target for any reason (including `detachFromTarget` command). Can be
         * issued multiple times per target if multiple sessions have been attached to it.
         */
        on(event: "detachedFromTarget", listener: (params: Protocol.Target.DetachedFromTargetEvent) => void): void;
        on(event: `detachedFromTarget.${SessionId}`, listener: (params: Protocol.Target.DetachedFromTargetEvent) => void): void;
        once(event: "detachedFromTarget", listener: (params: Protocol.Target.DetachedFromTargetEvent) => void): void;
        once(event: `detachedFromTarget.${SessionId}`, listener: (params: Protocol.Target.DetachedFromTargetEvent) => void): void;
        off(event: "detachedFromTarget", listener: (params: Protocol.Target.DetachedFromTargetEvent) => void): void;
        off(event: `detachedFromTarget.${SessionId}`, listener: (params: Protocol.Target.DetachedFromTargetEvent) => void): void;
        detachedFromTarget(sessionId?: SessionId): Promise<Protocol.Target.DetachedFromTargetEvent>;

        /**
         * Notifies about a new protocol message received from the session (as reported in
         * `attachedToTarget` event).
         */
        on(event: "receivedMessageFromTarget", listener: (params: Protocol.Target.ReceivedMessageFromTargetEvent) => void): void;
        on(event: `receivedMessageFromTarget.${SessionId}`, listener: (params: Protocol.Target.ReceivedMessageFromTargetEvent) => void): void;
        once(event: "receivedMessageFromTarget", listener: (params: Protocol.Target.ReceivedMessageFromTargetEvent) => void): void;
        once(event: `receivedMessageFromTarget.${SessionId}`, listener: (params: Protocol.Target.ReceivedMessageFromTargetEvent) => void): void;
        off(event: "receivedMessageFromTarget", listener: (params: Protocol.Target.ReceivedMessageFromTargetEvent) => void): void;
        off(event: `receivedMessageFromTarget.${SessionId}`, listener: (params: Protocol.Target.ReceivedMessageFromTargetEvent) => void): void;
        receivedMessageFromTarget(sessionId?: SessionId): Promise<Protocol.Target.ReceivedMessageFromTargetEvent>;

        /**
         * Issued when a possible inspection target is created.
         */
        on(event: "targetCreated", listener: (params: Protocol.Target.TargetCreatedEvent) => void): void;
        on(event: `targetCreated.${SessionId}`, listener: (params: Protocol.Target.TargetCreatedEvent) => void): void;
        once(event: "targetCreated", listener: (params: Protocol.Target.TargetCreatedEvent) => void): void;
        once(event: `targetCreated.${SessionId}`, listener: (params: Protocol.Target.TargetCreatedEvent) => void): void;
        off(event: "targetCreated", listener: (params: Protocol.Target.TargetCreatedEvent) => void): void;
        off(event: `targetCreated.${SessionId}`, listener: (params: Protocol.Target.TargetCreatedEvent) => void): void;
        targetCreated(sessionId?: SessionId): Promise<Protocol.Target.TargetCreatedEvent>;

        /**
         * Issued when a target is destroyed.
         */
        on(event: "targetDestroyed", listener: (params: Protocol.Target.TargetDestroyedEvent) => void): void;
        on(event: `targetDestroyed.${SessionId}`, listener: (params: Protocol.Target.TargetDestroyedEvent) => void): void;
        once(event: "targetDestroyed", listener: (params: Protocol.Target.TargetDestroyedEvent) => void): void;
        once(event: `targetDestroyed.${SessionId}`, listener: (params: Protocol.Target.TargetDestroyedEvent) => void): void;
        off(event: "targetDestroyed", listener: (params: Protocol.Target.TargetDestroyedEvent) => void): void;
        off(event: `targetDestroyed.${SessionId}`, listener: (params: Protocol.Target.TargetDestroyedEvent) => void): void;
        targetDestroyed(sessionId?: SessionId): Promise<Protocol.Target.TargetDestroyedEvent>;

        /**
         * Issued when a target has crashed.
         */
        on(event: "targetCrashed", listener: (params: Protocol.Target.TargetCrashedEvent) => void): void;
        on(event: `targetCrashed.${SessionId}`, listener: (params: Protocol.Target.TargetCrashedEvent) => void): void;
        once(event: "targetCrashed", listener: (params: Protocol.Target.TargetCrashedEvent) => void): void;
        once(event: `targetCrashed.${SessionId}`, listener: (params: Protocol.Target.TargetCrashedEvent) => void): void;
        off(event: "targetCrashed", listener: (params: Protocol.Target.TargetCrashedEvent) => void): void;
        off(event: `targetCrashed.${SessionId}`, listener: (params: Protocol.Target.TargetCrashedEvent) => void): void;
        targetCrashed(sessionId?: SessionId): Promise<Protocol.Target.TargetCrashedEvent>;

        /**
         * Issued when some information about a target has changed. This only happens between
         * `targetCreated` and `targetDestroyed`.
         */
        on(event: "targetInfoChanged", listener: (params: Protocol.Target.TargetInfoChangedEvent) => void): void;
        on(event: `targetInfoChanged.${SessionId}`, listener: (params: Protocol.Target.TargetInfoChangedEvent) => void): void;
        once(event: "targetInfoChanged", listener: (params: Protocol.Target.TargetInfoChangedEvent) => void): void;
        once(event: `targetInfoChanged.${SessionId}`, listener: (params: Protocol.Target.TargetInfoChangedEvent) => void): void;
        off(event: "targetInfoChanged", listener: (params: Protocol.Target.TargetInfoChangedEvent) => void): void;
        off(event: `targetInfoChanged.${SessionId}`, listener: (params: Protocol.Target.TargetInfoChangedEvent) => void): void;
        targetInfoChanged(sessionId?: SessionId): Promise<Protocol.Target.TargetInfoChangedEvent>;

    }

    export type TetheringApi = {
        /**
         * Request browser port binding.
         */
        bind(params: Protocol.Tethering.BindRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Request browser port unbinding.
         */
        unbind(params: Protocol.Tethering.UnbindRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Informs that port was successfully bound and got a specified connection id.
         */
        on(event: "accepted", listener: (params: Protocol.Tethering.AcceptedEvent) => void): void;
        on(event: `accepted.${SessionId}`, listener: (params: Protocol.Tethering.AcceptedEvent) => void): void;
        once(event: "accepted", listener: (params: Protocol.Tethering.AcceptedEvent) => void): void;
        once(event: `accepted.${SessionId}`, listener: (params: Protocol.Tethering.AcceptedEvent) => void): void;
        off(event: "accepted", listener: (params: Protocol.Tethering.AcceptedEvent) => void): void;
        off(event: `accepted.${SessionId}`, listener: (params: Protocol.Tethering.AcceptedEvent) => void): void;
        accepted(sessionId?: SessionId): Promise<Protocol.Tethering.AcceptedEvent>;

    }

    export type TracingApi = {
        /**
         * Stop trace events collection.
         */
        end(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Gets supported tracing categories.
         */
        getCategories(params?: Record<never, never>, sessionId?: SessionId): Promise<Protocol.Tracing.GetCategoriesResponse>;

        /**
         * Record a clock sync marker in the trace.
         */
        recordClockSyncMarker(params: Protocol.Tracing.RecordClockSyncMarkerRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Request a global memory dump.
         */
        requestMemoryDump(params?: Protocol.Tracing.RequestMemoryDumpRequest, sessionId?: SessionId): Promise<Protocol.Tracing.RequestMemoryDumpResponse>;

        /**
         * Start trace events collection.
         */
        start(params?: Protocol.Tracing.StartRequest, sessionId?: SessionId): Promise<void>;

        on(event: "bufferUsage", listener: (params: Protocol.Tracing.BufferUsageEvent) => void): void;
        on(event: `bufferUsage.${SessionId}`, listener: (params: Protocol.Tracing.BufferUsageEvent) => void): void;
        once(event: "bufferUsage", listener: (params: Protocol.Tracing.BufferUsageEvent) => void): void;
        once(event: `bufferUsage.${SessionId}`, listener: (params: Protocol.Tracing.BufferUsageEvent) => void): void;
        off(event: "bufferUsage", listener: (params: Protocol.Tracing.BufferUsageEvent) => void): void;
        off(event: `bufferUsage.${SessionId}`, listener: (params: Protocol.Tracing.BufferUsageEvent) => void): void;
        bufferUsage(sessionId?: SessionId): Promise<Protocol.Tracing.BufferUsageEvent>;

        /**
         * Contains a bucket of collected trace events. When tracing is stopped collected events will be
         * sent as a sequence of dataCollected events followed by tracingComplete event.
         */
        on(event: "dataCollected", listener: (params: Protocol.Tracing.DataCollectedEvent) => void): void;
        on(event: `dataCollected.${SessionId}`, listener: (params: Protocol.Tracing.DataCollectedEvent) => void): void;
        once(event: "dataCollected", listener: (params: Protocol.Tracing.DataCollectedEvent) => void): void;
        once(event: `dataCollected.${SessionId}`, listener: (params: Protocol.Tracing.DataCollectedEvent) => void): void;
        off(event: "dataCollected", listener: (params: Protocol.Tracing.DataCollectedEvent) => void): void;
        off(event: `dataCollected.${SessionId}`, listener: (params: Protocol.Tracing.DataCollectedEvent) => void): void;
        dataCollected(sessionId?: SessionId): Promise<Protocol.Tracing.DataCollectedEvent>;

        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        on(event: "tracingComplete", listener: (params: Protocol.Tracing.TracingCompleteEvent) => void): void;
        on(event: `tracingComplete.${SessionId}`, listener: (params: Protocol.Tracing.TracingCompleteEvent) => void): void;
        once(event: "tracingComplete", listener: (params: Protocol.Tracing.TracingCompleteEvent) => void): void;
        once(event: `tracingComplete.${SessionId}`, listener: (params: Protocol.Tracing.TracingCompleteEvent) => void): void;
        off(event: "tracingComplete", listener: (params: Protocol.Tracing.TracingCompleteEvent) => void): void;
        off(event: `tracingComplete.${SessionId}`, listener: (params: Protocol.Tracing.TracingCompleteEvent) => void): void;
        tracingComplete(sessionId?: SessionId): Promise<Protocol.Tracing.TracingCompleteEvent>;

    }

    export type FetchApi = {
        /**
         * Disables the fetch domain.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Enables issuing of requestPaused events. A request will be paused until client
         * calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
         */
        enable(params?: Protocol.Fetch.EnableRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Causes the request to fail with specified reason.
         */
        failRequest(params: Protocol.Fetch.FailRequestRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Provides response to the request.
         */
        fulfillRequest(params: Protocol.Fetch.FulfillRequestRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Continues the request, optionally modifying some of its parameters.
         */
        continueRequest(params: Protocol.Fetch.ContinueRequestRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Continues a request supplying authChallengeResponse following authRequired event.
         */
        continueWithAuth(params: Protocol.Fetch.ContinueWithAuthRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Continues loading of the paused response, optionally modifying the
         * response headers. If either responseCode or headers are modified, all of them
         * must be present.
         */
        continueResponse(params: Protocol.Fetch.ContinueResponseRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Causes the body of the response to be received from the server and
         * returned as a single string. May only be issued for a request that
         * is paused in the Response stage and is mutually exclusive with
         * takeResponseBodyForInterceptionAsStream. Calling other methods that
         * affect the request or disabling fetch domain before body is received
         * results in an undefined behavior.
         */
        getResponseBody(params: Protocol.Fetch.GetResponseBodyRequest, sessionId?: SessionId): Promise<Protocol.Fetch.GetResponseBodyResponse>;

        /**
         * Returns a handle to the stream representing the response body.
         * The request must be paused in the HeadersReceived stage.
         * Note that after this command the request can't be continued
         * as is -- client either needs to cancel it or to provide the
         * response body.
         * The stream only supports sequential read, IO.read will fail if the position
         * is specified.
         * This method is mutually exclusive with getResponseBody.
         * Calling other methods that affect the request or disabling fetch
         * domain before body is received results in an undefined behavior.
         */
        takeResponseBodyAsStream(params: Protocol.Fetch.TakeResponseBodyAsStreamRequest, sessionId?: SessionId): Promise<Protocol.Fetch.TakeResponseBodyAsStreamResponse>;

        /**
         * Issued when the domain is enabled and the request URL matches the
         * specified filter. The request is paused until the client responds
         * with one of continueRequest, failRequest or fulfillRequest.
         * The stage of the request can be determined by presence of responseErrorReason
         * and responseStatusCode -- the request is at the response stage if either
         * of these fields is present and in the request stage otherwise.
         */
        on(event: "requestPaused", listener: (params: Protocol.Fetch.RequestPausedEvent) => void): void;
        on(event: `requestPaused.${SessionId}`, listener: (params: Protocol.Fetch.RequestPausedEvent) => void): void;
        once(event: "requestPaused", listener: (params: Protocol.Fetch.RequestPausedEvent) => void): void;
        once(event: `requestPaused.${SessionId}`, listener: (params: Protocol.Fetch.RequestPausedEvent) => void): void;
        off(event: "requestPaused", listener: (params: Protocol.Fetch.RequestPausedEvent) => void): void;
        off(event: `requestPaused.${SessionId}`, listener: (params: Protocol.Fetch.RequestPausedEvent) => void): void;
        requestPaused(sessionId?: SessionId): Promise<Protocol.Fetch.RequestPausedEvent>;

        /**
         * Issued when the domain is enabled with handleAuthRequests set to true.
         * The request is paused until client responds with continueWithAuth.
         */
        on(event: "authRequired", listener: (params: Protocol.Fetch.AuthRequiredEvent) => void): void;
        on(event: `authRequired.${SessionId}`, listener: (params: Protocol.Fetch.AuthRequiredEvent) => void): void;
        once(event: "authRequired", listener: (params: Protocol.Fetch.AuthRequiredEvent) => void): void;
        once(event: `authRequired.${SessionId}`, listener: (params: Protocol.Fetch.AuthRequiredEvent) => void): void;
        off(event: "authRequired", listener: (params: Protocol.Fetch.AuthRequiredEvent) => void): void;
        off(event: `authRequired.${SessionId}`, listener: (params: Protocol.Fetch.AuthRequiredEvent) => void): void;
        authRequired(sessionId?: SessionId): Promise<Protocol.Fetch.AuthRequiredEvent>;

    }

    export type WebAudioApi = {
        /**
         * Enables the WebAudio domain and starts sending context lifetime events.
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Disables the WebAudio domain.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Fetch the realtime data from the registered contexts.
         */
        getRealtimeData(params: Protocol.WebAudio.GetRealtimeDataRequest, sessionId?: SessionId): Promise<Protocol.WebAudio.GetRealtimeDataResponse>;

        /**
         * Notifies that a new BaseAudioContext has been created.
         */
        on(event: "contextCreated", listener: (params: Protocol.WebAudio.ContextCreatedEvent) => void): void;
        on(event: `contextCreated.${SessionId}`, listener: (params: Protocol.WebAudio.ContextCreatedEvent) => void): void;
        once(event: "contextCreated", listener: (params: Protocol.WebAudio.ContextCreatedEvent) => void): void;
        once(event: `contextCreated.${SessionId}`, listener: (params: Protocol.WebAudio.ContextCreatedEvent) => void): void;
        off(event: "contextCreated", listener: (params: Protocol.WebAudio.ContextCreatedEvent) => void): void;
        off(event: `contextCreated.${SessionId}`, listener: (params: Protocol.WebAudio.ContextCreatedEvent) => void): void;
        contextCreated(sessionId?: SessionId): Promise<Protocol.WebAudio.ContextCreatedEvent>;

        /**
         * Notifies that an existing BaseAudioContext will be destroyed.
         */
        on(event: "contextWillBeDestroyed", listener: (params: Protocol.WebAudio.ContextWillBeDestroyedEvent) => void): void;
        on(event: `contextWillBeDestroyed.${SessionId}`, listener: (params: Protocol.WebAudio.ContextWillBeDestroyedEvent) => void): void;
        once(event: "contextWillBeDestroyed", listener: (params: Protocol.WebAudio.ContextWillBeDestroyedEvent) => void): void;
        once(event: `contextWillBeDestroyed.${SessionId}`, listener: (params: Protocol.WebAudio.ContextWillBeDestroyedEvent) => void): void;
        off(event: "contextWillBeDestroyed", listener: (params: Protocol.WebAudio.ContextWillBeDestroyedEvent) => void): void;
        off(event: `contextWillBeDestroyed.${SessionId}`, listener: (params: Protocol.WebAudio.ContextWillBeDestroyedEvent) => void): void;
        contextWillBeDestroyed(sessionId?: SessionId): Promise<Protocol.WebAudio.ContextWillBeDestroyedEvent>;

        /**
         * Notifies that existing BaseAudioContext has changed some properties (id stays the same)..
         */
        on(event: "contextChanged", listener: (params: Protocol.WebAudio.ContextChangedEvent) => void): void;
        on(event: `contextChanged.${SessionId}`, listener: (params: Protocol.WebAudio.ContextChangedEvent) => void): void;
        once(event: "contextChanged", listener: (params: Protocol.WebAudio.ContextChangedEvent) => void): void;
        once(event: `contextChanged.${SessionId}`, listener: (params: Protocol.WebAudio.ContextChangedEvent) => void): void;
        off(event: "contextChanged", listener: (params: Protocol.WebAudio.ContextChangedEvent) => void): void;
        off(event: `contextChanged.${SessionId}`, listener: (params: Protocol.WebAudio.ContextChangedEvent) => void): void;
        contextChanged(sessionId?: SessionId): Promise<Protocol.WebAudio.ContextChangedEvent>;

        /**
         * Notifies that the construction of an AudioListener has finished.
         */
        on(event: "audioListenerCreated", listener: (params: Protocol.WebAudio.AudioListenerCreatedEvent) => void): void;
        on(event: `audioListenerCreated.${SessionId}`, listener: (params: Protocol.WebAudio.AudioListenerCreatedEvent) => void): void;
        once(event: "audioListenerCreated", listener: (params: Protocol.WebAudio.AudioListenerCreatedEvent) => void): void;
        once(event: `audioListenerCreated.${SessionId}`, listener: (params: Protocol.WebAudio.AudioListenerCreatedEvent) => void): void;
        off(event: "audioListenerCreated", listener: (params: Protocol.WebAudio.AudioListenerCreatedEvent) => void): void;
        off(event: `audioListenerCreated.${SessionId}`, listener: (params: Protocol.WebAudio.AudioListenerCreatedEvent) => void): void;
        audioListenerCreated(sessionId?: SessionId): Promise<Protocol.WebAudio.AudioListenerCreatedEvent>;

        /**
         * Notifies that a new AudioListener has been created.
         */
        on(event: "audioListenerWillBeDestroyed", listener: (params: Protocol.WebAudio.AudioListenerWillBeDestroyedEvent) => void): void;
        on(event: `audioListenerWillBeDestroyed.${SessionId}`, listener: (params: Protocol.WebAudio.AudioListenerWillBeDestroyedEvent) => void): void;
        once(event: "audioListenerWillBeDestroyed", listener: (params: Protocol.WebAudio.AudioListenerWillBeDestroyedEvent) => void): void;
        once(event: `audioListenerWillBeDestroyed.${SessionId}`, listener: (params: Protocol.WebAudio.AudioListenerWillBeDestroyedEvent) => void): void;
        off(event: "audioListenerWillBeDestroyed", listener: (params: Protocol.WebAudio.AudioListenerWillBeDestroyedEvent) => void): void;
        off(event: `audioListenerWillBeDestroyed.${SessionId}`, listener: (params: Protocol.WebAudio.AudioListenerWillBeDestroyedEvent) => void): void;
        audioListenerWillBeDestroyed(sessionId?: SessionId): Promise<Protocol.WebAudio.AudioListenerWillBeDestroyedEvent>;

        /**
         * Notifies that a new AudioNode has been created.
         */
        on(event: "audioNodeCreated", listener: (params: Protocol.WebAudio.AudioNodeCreatedEvent) => void): void;
        on(event: `audioNodeCreated.${SessionId}`, listener: (params: Protocol.WebAudio.AudioNodeCreatedEvent) => void): void;
        once(event: "audioNodeCreated", listener: (params: Protocol.WebAudio.AudioNodeCreatedEvent) => void): void;
        once(event: `audioNodeCreated.${SessionId}`, listener: (params: Protocol.WebAudio.AudioNodeCreatedEvent) => void): void;
        off(event: "audioNodeCreated", listener: (params: Protocol.WebAudio.AudioNodeCreatedEvent) => void): void;
        off(event: `audioNodeCreated.${SessionId}`, listener: (params: Protocol.WebAudio.AudioNodeCreatedEvent) => void): void;
        audioNodeCreated(sessionId?: SessionId): Promise<Protocol.WebAudio.AudioNodeCreatedEvent>;

        /**
         * Notifies that an existing AudioNode has been destroyed.
         */
        on(event: "audioNodeWillBeDestroyed", listener: (params: Protocol.WebAudio.AudioNodeWillBeDestroyedEvent) => void): void;
        on(event: `audioNodeWillBeDestroyed.${SessionId}`, listener: (params: Protocol.WebAudio.AudioNodeWillBeDestroyedEvent) => void): void;
        once(event: "audioNodeWillBeDestroyed", listener: (params: Protocol.WebAudio.AudioNodeWillBeDestroyedEvent) => void): void;
        once(event: `audioNodeWillBeDestroyed.${SessionId}`, listener: (params: Protocol.WebAudio.AudioNodeWillBeDestroyedEvent) => void): void;
        off(event: "audioNodeWillBeDestroyed", listener: (params: Protocol.WebAudio.AudioNodeWillBeDestroyedEvent) => void): void;
        off(event: `audioNodeWillBeDestroyed.${SessionId}`, listener: (params: Protocol.WebAudio.AudioNodeWillBeDestroyedEvent) => void): void;
        audioNodeWillBeDestroyed(sessionId?: SessionId): Promise<Protocol.WebAudio.AudioNodeWillBeDestroyedEvent>;

        /**
         * Notifies that a new AudioParam has been created.
         */
        on(event: "audioParamCreated", listener: (params: Protocol.WebAudio.AudioParamCreatedEvent) => void): void;
        on(event: `audioParamCreated.${SessionId}`, listener: (params: Protocol.WebAudio.AudioParamCreatedEvent) => void): void;
        once(event: "audioParamCreated", listener: (params: Protocol.WebAudio.AudioParamCreatedEvent) => void): void;
        once(event: `audioParamCreated.${SessionId}`, listener: (params: Protocol.WebAudio.AudioParamCreatedEvent) => void): void;
        off(event: "audioParamCreated", listener: (params: Protocol.WebAudio.AudioParamCreatedEvent) => void): void;
        off(event: `audioParamCreated.${SessionId}`, listener: (params: Protocol.WebAudio.AudioParamCreatedEvent) => void): void;
        audioParamCreated(sessionId?: SessionId): Promise<Protocol.WebAudio.AudioParamCreatedEvent>;

        /**
         * Notifies that an existing AudioParam has been destroyed.
         */
        on(event: "audioParamWillBeDestroyed", listener: (params: Protocol.WebAudio.AudioParamWillBeDestroyedEvent) => void): void;
        on(event: `audioParamWillBeDestroyed.${SessionId}`, listener: (params: Protocol.WebAudio.AudioParamWillBeDestroyedEvent) => void): void;
        once(event: "audioParamWillBeDestroyed", listener: (params: Protocol.WebAudio.AudioParamWillBeDestroyedEvent) => void): void;
        once(event: `audioParamWillBeDestroyed.${SessionId}`, listener: (params: Protocol.WebAudio.AudioParamWillBeDestroyedEvent) => void): void;
        off(event: "audioParamWillBeDestroyed", listener: (params: Protocol.WebAudio.AudioParamWillBeDestroyedEvent) => void): void;
        off(event: `audioParamWillBeDestroyed.${SessionId}`, listener: (params: Protocol.WebAudio.AudioParamWillBeDestroyedEvent) => void): void;
        audioParamWillBeDestroyed(sessionId?: SessionId): Promise<Protocol.WebAudio.AudioParamWillBeDestroyedEvent>;

        /**
         * Notifies that two AudioNodes are connected.
         */
        on(event: "nodesConnected", listener: (params: Protocol.WebAudio.NodesConnectedEvent) => void): void;
        on(event: `nodesConnected.${SessionId}`, listener: (params: Protocol.WebAudio.NodesConnectedEvent) => void): void;
        once(event: "nodesConnected", listener: (params: Protocol.WebAudio.NodesConnectedEvent) => void): void;
        once(event: `nodesConnected.${SessionId}`, listener: (params: Protocol.WebAudio.NodesConnectedEvent) => void): void;
        off(event: "nodesConnected", listener: (params: Protocol.WebAudio.NodesConnectedEvent) => void): void;
        off(event: `nodesConnected.${SessionId}`, listener: (params: Protocol.WebAudio.NodesConnectedEvent) => void): void;
        nodesConnected(sessionId?: SessionId): Promise<Protocol.WebAudio.NodesConnectedEvent>;

        /**
         * Notifies that AudioNodes are disconnected. The destination can be null, and it means all the outgoing connections from the source are disconnected.
         */
        on(event: "nodesDisconnected", listener: (params: Protocol.WebAudio.NodesDisconnectedEvent) => void): void;
        on(event: `nodesDisconnected.${SessionId}`, listener: (params: Protocol.WebAudio.NodesDisconnectedEvent) => void): void;
        once(event: "nodesDisconnected", listener: (params: Protocol.WebAudio.NodesDisconnectedEvent) => void): void;
        once(event: `nodesDisconnected.${SessionId}`, listener: (params: Protocol.WebAudio.NodesDisconnectedEvent) => void): void;
        off(event: "nodesDisconnected", listener: (params: Protocol.WebAudio.NodesDisconnectedEvent) => void): void;
        off(event: `nodesDisconnected.${SessionId}`, listener: (params: Protocol.WebAudio.NodesDisconnectedEvent) => void): void;
        nodesDisconnected(sessionId?: SessionId): Promise<Protocol.WebAudio.NodesDisconnectedEvent>;

        /**
         * Notifies that an AudioNode is connected to an AudioParam.
         */
        on(event: "nodeParamConnected", listener: (params: Protocol.WebAudio.NodeParamConnectedEvent) => void): void;
        on(event: `nodeParamConnected.${SessionId}`, listener: (params: Protocol.WebAudio.NodeParamConnectedEvent) => void): void;
        once(event: "nodeParamConnected", listener: (params: Protocol.WebAudio.NodeParamConnectedEvent) => void): void;
        once(event: `nodeParamConnected.${SessionId}`, listener: (params: Protocol.WebAudio.NodeParamConnectedEvent) => void): void;
        off(event: "nodeParamConnected", listener: (params: Protocol.WebAudio.NodeParamConnectedEvent) => void): void;
        off(event: `nodeParamConnected.${SessionId}`, listener: (params: Protocol.WebAudio.NodeParamConnectedEvent) => void): void;
        nodeParamConnected(sessionId?: SessionId): Promise<Protocol.WebAudio.NodeParamConnectedEvent>;

        /**
         * Notifies that an AudioNode is disconnected to an AudioParam.
         */
        on(event: "nodeParamDisconnected", listener: (params: Protocol.WebAudio.NodeParamDisconnectedEvent) => void): void;
        on(event: `nodeParamDisconnected.${SessionId}`, listener: (params: Protocol.WebAudio.NodeParamDisconnectedEvent) => void): void;
        once(event: "nodeParamDisconnected", listener: (params: Protocol.WebAudio.NodeParamDisconnectedEvent) => void): void;
        once(event: `nodeParamDisconnected.${SessionId}`, listener: (params: Protocol.WebAudio.NodeParamDisconnectedEvent) => void): void;
        off(event: "nodeParamDisconnected", listener: (params: Protocol.WebAudio.NodeParamDisconnectedEvent) => void): void;
        off(event: `nodeParamDisconnected.${SessionId}`, listener: (params: Protocol.WebAudio.NodeParamDisconnectedEvent) => void): void;
        nodeParamDisconnected(sessionId?: SessionId): Promise<Protocol.WebAudio.NodeParamDisconnectedEvent>;

    }

    export type WebAuthnApi = {
        /**
         * Enable the WebAuthn domain and start intercepting credential storage and
         * retrieval with a virtual authenticator.
         */
        enable(params?: Protocol.WebAuthn.EnableRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Disable the WebAuthn domain.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Creates and adds a virtual authenticator.
         */
        addVirtualAuthenticator(params: Protocol.WebAuthn.AddVirtualAuthenticatorRequest, sessionId?: SessionId): Promise<Protocol.WebAuthn.AddVirtualAuthenticatorResponse>;

        /**
         * Resets parameters isBogusSignature, isBadUV, isBadUP to false if they are not present.
         */
        setResponseOverrideBits(params: Protocol.WebAuthn.SetResponseOverrideBitsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Removes the given authenticator.
         */
        removeVirtualAuthenticator(params: Protocol.WebAuthn.RemoveVirtualAuthenticatorRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Adds the credential to the specified authenticator.
         */
        addCredential(params: Protocol.WebAuthn.AddCredentialRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Returns a single credential stored in the given virtual authenticator that
         * matches the credential ID.
         */
        getCredential(params: Protocol.WebAuthn.GetCredentialRequest, sessionId?: SessionId): Promise<Protocol.WebAuthn.GetCredentialResponse>;

        /**
         * Returns all the credentials stored in the given virtual authenticator.
         */
        getCredentials(params: Protocol.WebAuthn.GetCredentialsRequest, sessionId?: SessionId): Promise<Protocol.WebAuthn.GetCredentialsResponse>;

        /**
         * Removes a credential from the authenticator.
         */
        removeCredential(params: Protocol.WebAuthn.RemoveCredentialRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Clears all the credentials from the specified device.
         */
        clearCredentials(params: Protocol.WebAuthn.ClearCredentialsRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets whether User Verification succeeds or fails for an authenticator.
         * The default is true.
         */
        setUserVerified(params: Protocol.WebAuthn.SetUserVerifiedRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.
         * The default is true.
         */
        setAutomaticPresenceSimulation(params: Protocol.WebAuthn.SetAutomaticPresenceSimulationRequest, sessionId?: SessionId): Promise<void>;

        /**
         * Triggered when a credential is added to an authenticator.
         */
        on(event: "credentialAdded", listener: (params: Protocol.WebAuthn.CredentialAddedEvent) => void): void;
        on(event: `credentialAdded.${SessionId}`, listener: (params: Protocol.WebAuthn.CredentialAddedEvent) => void): void;
        once(event: "credentialAdded", listener: (params: Protocol.WebAuthn.CredentialAddedEvent) => void): void;
        once(event: `credentialAdded.${SessionId}`, listener: (params: Protocol.WebAuthn.CredentialAddedEvent) => void): void;
        off(event: "credentialAdded", listener: (params: Protocol.WebAuthn.CredentialAddedEvent) => void): void;
        off(event: `credentialAdded.${SessionId}`, listener: (params: Protocol.WebAuthn.CredentialAddedEvent) => void): void;
        credentialAdded(sessionId?: SessionId): Promise<Protocol.WebAuthn.CredentialAddedEvent>;

        /**
         * Triggered when a credential is used in a webauthn assertion.
         */
        on(event: "credentialAsserted", listener: (params: Protocol.WebAuthn.CredentialAssertedEvent) => void): void;
        on(event: `credentialAsserted.${SessionId}`, listener: (params: Protocol.WebAuthn.CredentialAssertedEvent) => void): void;
        once(event: "credentialAsserted", listener: (params: Protocol.WebAuthn.CredentialAssertedEvent) => void): void;
        once(event: `credentialAsserted.${SessionId}`, listener: (params: Protocol.WebAuthn.CredentialAssertedEvent) => void): void;
        off(event: "credentialAsserted", listener: (params: Protocol.WebAuthn.CredentialAssertedEvent) => void): void;
        off(event: `credentialAsserted.${SessionId}`, listener: (params: Protocol.WebAuthn.CredentialAssertedEvent) => void): void;
        credentialAsserted(sessionId?: SessionId): Promise<Protocol.WebAuthn.CredentialAssertedEvent>;

    }

    export type MediaApi = {
        /**
         * Enables the Media domain
         */
        enable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * Disables the Media domain.
         */
        disable(params?: Record<never, never>, sessionId?: SessionId): Promise<void>;

        /**
         * This can be called multiple times, and can be used to set / override /
         * remove player properties. A null propValue indicates removal.
         */
        on(event: "playerPropertiesChanged", listener: (params: Protocol.Media.PlayerPropertiesChangedEvent) => void): void;
        on(event: `playerPropertiesChanged.${SessionId}`, listener: (params: Protocol.Media.PlayerPropertiesChangedEvent) => void): void;
        once(event: "playerPropertiesChanged", listener: (params: Protocol.Media.PlayerPropertiesChangedEvent) => void): void;
        once(event: `playerPropertiesChanged.${SessionId}`, listener: (params: Protocol.Media.PlayerPropertiesChangedEvent) => void): void;
        off(event: "playerPropertiesChanged", listener: (params: Protocol.Media.PlayerPropertiesChangedEvent) => void): void;
        off(event: `playerPropertiesChanged.${SessionId}`, listener: (params: Protocol.Media.PlayerPropertiesChangedEvent) => void): void;
        playerPropertiesChanged(sessionId?: SessionId): Promise<Protocol.Media.PlayerPropertiesChangedEvent>;

        /**
         * Send events as a list, allowing them to be batched on the browser for less
         * congestion. If batched, events must ALWAYS be in chronological order.
         */
        on(event: "playerEventsAdded", listener: (params: Protocol.Media.PlayerEventsAddedEvent) => void): void;
        on(event: `playerEventsAdded.${SessionId}`, listener: (params: Protocol.Media.PlayerEventsAddedEvent) => void): void;
        once(event: "playerEventsAdded", listener: (params: Protocol.Media.PlayerEventsAddedEvent) => void): void;
        once(event: `playerEventsAdded.${SessionId}`, listener: (params: Protocol.Media.PlayerEventsAddedEvent) => void): void;
        off(event: "playerEventsAdded", listener: (params: Protocol.Media.PlayerEventsAddedEvent) => void): void;
        off(event: `playerEventsAdded.${SessionId}`, listener: (params: Protocol.Media.PlayerEventsAddedEvent) => void): void;
        playerEventsAdded(sessionId?: SessionId): Promise<Protocol.Media.PlayerEventsAddedEvent>;

        /**
         * Send a list of any messages that need to be delivered.
         */
        on(event: "playerMessagesLogged", listener: (params: Protocol.Media.PlayerMessagesLoggedEvent) => void): void;
        on(event: `playerMessagesLogged.${SessionId}`, listener: (params: Protocol.Media.PlayerMessagesLoggedEvent) => void): void;
        once(event: "playerMessagesLogged", listener: (params: Protocol.Media.PlayerMessagesLoggedEvent) => void): void;
        once(event: `playerMessagesLogged.${SessionId}`, listener: (params: Protocol.Media.PlayerMessagesLoggedEvent) => void): void;
        off(event: "playerMessagesLogged", listener: (params: Protocol.Media.PlayerMessagesLoggedEvent) => void): void;
        off(event: `playerMessagesLogged.${SessionId}`, listener: (params: Protocol.Media.PlayerMessagesLoggedEvent) => void): void;
        playerMessagesLogged(sessionId?: SessionId): Promise<Protocol.Media.PlayerMessagesLoggedEvent>;

        /**
         * Send a list of any errors that need to be delivered.
         */
        on(event: "playerErrorsRaised", listener: (params: Protocol.Media.PlayerErrorsRaisedEvent) => void): void;
        on(event: `playerErrorsRaised.${SessionId}`, listener: (params: Protocol.Media.PlayerErrorsRaisedEvent) => void): void;
        once(event: "playerErrorsRaised", listener: (params: Protocol.Media.PlayerErrorsRaisedEvent) => void): void;
        once(event: `playerErrorsRaised.${SessionId}`, listener: (params: Protocol.Media.PlayerErrorsRaisedEvent) => void): void;
        off(event: "playerErrorsRaised", listener: (params: Protocol.Media.PlayerErrorsRaisedEvent) => void): void;
        off(event: `playerErrorsRaised.${SessionId}`, listener: (params: Protocol.Media.PlayerErrorsRaisedEvent) => void): void;
        playerErrorsRaised(sessionId?: SessionId): Promise<Protocol.Media.PlayerErrorsRaisedEvent>;

        /**
         * Called whenever a player is created, or when a new agent joins and receives
         * a list of active players. If an agent is restored, it will receive the full
         * list of player ids and all events again.
         */
        on(event: "playersCreated", listener: (params: Protocol.Media.PlayersCreatedEvent) => void): void;
        on(event: `playersCreated.${SessionId}`, listener: (params: Protocol.Media.PlayersCreatedEvent) => void): void;
        once(event: "playersCreated", listener: (params: Protocol.Media.PlayersCreatedEvent) => void): void;
        once(event: `playersCreated.${SessionId}`, listener: (params: Protocol.Media.PlayersCreatedEvent) => void): void;
        off(event: "playersCreated", listener: (params: Protocol.Media.PlayersCreatedEvent) => void): void;
        off(event: `playersCreated.${SessionId}`, listener: (params: Protocol.Media.PlayersCreatedEvent) => void): void;
        playersCreated(sessionId?: SessionId): Promise<Protocol.Media.PlayersCreatedEvent>;

    }
}

export default ProtocolProxyApi;
